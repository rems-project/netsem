%%%% AUTOGENERATED FILE (from MNG source) -- DO NOT EDIT! %%%%































































% this is a -*- latex -*- document really
%%2009-02-18%\documentclass[a4paper,11pt,twocolumn]{article}
%%2009-02-18%\documentclass[nocopyrightspace,preprint]{sigplanconf} % and uncomment
%%2009-02-18                                % amspackages
%%2009-02-18%\documentclass[conference,letterpaper]{IEEE/IEEEtran} % and uncomment
%%2009-02-18                                % amspackages
%%2009-02-18%\documentclass{llncs2e/llncs} % and uncomment amspackages
%%2009-02-18
%%2009-02-18%\usepackage{float}
%%2009-02-18%\restylefloat{figure} \floatstyle{ruled}
%%2009-02-18%FIXME change rule style in figures to omit bounding box
%%2009-02-18%\floatstyle{plain}
%%2009-02-18
%%2009-02-18\usepackage{color}
%%2009-02-18%\usepackage{multicol}
%%2009-02-18\newcommand{\nnn}{30}
%%2009-02-18
%%2009-02-18% hack: these two seem to be required for some reason, but are not
%%2009-02-18% defined on P's laptop latex
%%2009-02-18%\definecolor{lightgray}{rgb}{0.5,0.5,0.5}
%%2009-02-18%\definecolor{darkgray}{rgb}{0.2,0.2,0.2}
%%2009-02-18
%%2009-02-18\newif\iffinal\finaltrue
%%2009-02-18
%%2009-02-18\sloppy
%%2009-02-18
%%2009-02-18%\newif\ifdraft\drafttrue
%%2009-02-18\newif\ifdraft\draftfalse
%%2009-02-18
%%2009-02-18%\newif\ifanon\anontrue
%%2009-02-18\newif\ifanon\anonfalse
%%2009-02-18
%%2009-02-18%\iffinal
%%2009-02-18%\else
%%2009-02-18%\usepackage{geometry}
%%2009-02-18%\fi
%%2009-02-18
%%2009-02-18\newcommand{\trimbox}[1]{\raisebox{0pt}[1.20ex][0.2ex]{#1}}
%%2009-02-18\newcommand{\cg}[1]{\colorbox{lightgray}{\trimbox{$#1$}}}
%%2009-02-18
%%2009-02-18
%%2009-02-18\usepackage{ltsmunge}
%%2009-02-18%\usepackage{multicol}
%%2009-02-18
%%2009-02-18\renewcommand{\tsunknown}[1]{\tsvar{#1}}
%%2009-02-18
%%2009-02-18\usepackage{tcp}
%%2009-02-18%\usepackage{alldoctex/tcp}
%%2009-02-18\usepackage{url}
%%2009-02-18\usepackage{alltt}
%%2009-02-18
%%2009-02-18\usepackage{epsfig}
%%2009-02-18\usepackage{psfrag}
%%2009-02-18% for Michael's text
%%2009-02-18\usepackage{pstricks}
%%2009-02-18%\usepackage{pst-node}
%%2009-02-18 \usepackage{proof}
%%2009-02-18% \usepackage[all]{xy}
%%2009-02-18
%%2009-02-18\usepackage{verbatim}
%%2009-02-18%\usepackage{parskip}
%%2009-02-18%\usepackage{float}
%%2009-02-18%\floatstyle{ruled}
%%2009-02-18%\restylefloat{table}
%%2009-02-18\usepackage{graphics}
%%2009-02-18
%%2009-02-18\usepackage{array}
%%2009-02-18
%%2009-02-18
%%2009-02-18% Non-enclosing figure brackets, by Keith Wansbrough
%%2009-02-18%   (after Andy Gordon and Don Syme)
%%2009-02-18%\newlength{\BrackWidth}\setlength{\BrackWidth}{0.7pt}
%%2009-02-18\newlength{\varDashLength}\setlength{\varDashLength}{2pt}
%%2009-02-18\newcommand{\varTopBracket}{%
%%2009-02-18  \par\noindent
%%2009-02-18  \rlap{\rule[-\varDashLength]{\BrackWidth}{\varDashLength}}%
%%2009-02-18  \rule{\linewidth}{\BrackWidth}%
%%2009-02-18  \llap{\rule[-\varDashLength]{\BrackWidth}{\varDashLength}}%
%%2009-02-18  \par
%%2009-02-18}
%%2009-02-18\newcommand{\varBottomBracket}{%
%%2009-02-18  \par\noindent
%%2009-02-18  \rlap{\rule{\BrackWidth}{\varDashLength}}%
%%2009-02-18  \rule{\linewidth}{\BrackWidth}%
%%2009-02-18  \llap{\rule{\BrackWidth}{\varDashLength}}%
%%2009-02-18  \par
%%2009-02-18}
%%2009-02-18\newcommand{\varrrenbox}[1]{%
%%2009-02-18  \varTopBracket
%%2009-02-18%  \rrnormalsize{}
%%2009-02-18\vspace{-2mm}
%%2009-02-18{\small
%%2009-02-18  #1%
%%2009-02-18}
%%2009-02-18\vspace{-3mm}
%%2009-02-18\varBottomBracket
%%2009-02-18}
%%2009-02-18
%%2009-02-18\renewcommand{\ddefnn}[4]{%
%%2009-02-18  \varrrenbox{%
%%2009-02-18    \dodefnindex{#2}%
%%2009-02-18    \ltslabel{#1}%
%%2009-02-18    \rrenside{#3}%
%%2009-02-18  }%
%%2009-02-18}
%%2009-02-18
%%2009-02-18
%%2009-02-18\iffinal
%%2009-02-18\else
%%2009-02-18  \geometry{
%%2009-02-18    paperwidth=8.5in,    % US Letter
%%2009-02-18    paperheight=11in,    %
%%2009-02-18    dvips,
%%2009-02-18    twoside,
%%2009-02-18    twosideshift=0mm,
%%2009-02-18    left=1.0in, textwidth=6.5in, %right=25.4mm,
%%2009-02-18    top=0mm,  %bottom=30mm,
%%2009-02-18    textheight=9.0in,
%%2009-02-18    headheight=5mm,
%%2009-02-18    %headsep=00mm, footskip=10mm, %should be equal
%%2009-02-18%
%%2009-02-18%20pc (3.33in) wide and 54pc (9in) tall with a column gutter of 2pc (0.33in)
%%2009-02-18% so 7in wide, 9in tall.
%%2009-02-18%    177.8mm   228.6
%%2009-02-18% leaving from a4:  32.2mm   68.4mm
%%2009-02-18% dividing by 2:    16.1mm    ...
%%2009-02-18%    left=16.1mm, right=16.1mm,
%%2009-02-18%    top=20mm,  bottom=28.4mm,
%%2009-02-18  }
%%2009-02-18\fi
%%2009-02-18
%%2009-02-18%   \geometry{
%%2009-02-18%     paperwidth=210mm,    % US Letter /\ ISO A4
%%2009-02-18%     paperheight=11in,    %
%%2009-02-18%     dvips,
%%2009-02-18%     twoside,
%%2009-02-18%     twosideshift=0mm,
%%2009-02-18%     left=25.4mm, right=25.4mm,
%%2009-02-18%     top=20mm,  bottom=30mm,
%%2009-02-18%     headheight=\baselineskip,
%%2009-02-18%     headsep=10mm, footskip=10mm, %should be equal
%%2009-02-18% %
%%2009-02-18% %20pc (3.33in) wide and 54pc (9in) tall with a column gutter of 2pc (0.33in)
%%2009-02-18% % so 7in wide, 9in tall.
%%2009-02-18% %    177.8mm   228.6
%%2009-02-18% % leaving from a4:  32.2mm   68.4mm
%%2009-02-18% % dividing by 2:    16.1mm    ...
%%2009-02-18% %    left=16.1mm, right=16.1mm,
%%2009-02-18% %    top=20mm,  bottom=28.4mm,
%%2009-02-18%   }
%%2009-02-18
%%2009-02-18
%%2009-02-18%\usepackage{fullpage}
%%2009-02-18
%%2009-02-18\newenvironment{tightlist}{\begin{list}{$\bullet$}{
%%2009-02-18  \setlength{\itemsep}{0mm}
%%2009-02-18  \setlength{\parsep}{0mm}
%%2009-02-18  \setlength{\itemindent}{3mm}
%%2009-02-18  \setlength{\leftmargin}{3mm}
%%2009-02-18%  \setlength{\labelsep}{0mm}
%%2009-02-18%  \setlength{\labelwidth}{0mm}
%%2009-02-18%  \setlength{\topsep}{0mm}
%%2009-02-18}}{\end{list}}
%%2009-02-18
%%2009-02-18\usepackage{xspace}
%%2009-02-18 \newcommand{\eg}{e.g.\@\xspace}
%%2009-02-18 \newcommand{\cf}{cf.\@\xspace}
%%2009-02-18 \newcommand{\wrt}{w.r.t.\@\xspace}
%%2009-02-18 \newcommand{\etal}{\emph{et al.}\@\xspace}
%%2009-02-18 \newcommand{\ia}{inter alia\xspace}
%%2009-02-18 \newcommand{\etc}{etc.\@\xspace}
%%2009-02-18
%%2009-02-18
%%2009-02-18%\newcommand{\myheading}[1]{\noindent\textbf{#1}}
%%2009-02-18
%%2009-02-18\newcommand{\myheading}[1]{\vspace{0.5\baselineskip}\par\noindent\textbf{#1}\quad}
%%2009-02-18\newcommand{\myfirstheading}[1]{\par\noindent\textbf{#1}\quad}
%%2009-02-18
%%2009-02-18
%%2009-02-18%\input{generated/alldoc-inc.tex}
%%2009-02-18\input{generated/Spec3_alldoc-inc.tex}
%%2009-02-18
%%2009-02-18\begin{document}
%%2009-02-18
%%2009-02-18\title{A rigorous approach to networking: \\TCP, from implementation to protocol to service}
%%2009-02-18
%%2009-02-18
%%2009-02-18\author{Tom Ridge\inst{1}, Michael Norrish\inst{2}, and Peter Sewell\inst{1}}
%%2009-02-18
%%2009-02-18\institute{University of Cambridge \and NICTA}
%%2009-02-18
%%2009-02-18%\author{
%%2009-02-18%\IEEEauthorblockN{Michael Norrish}\IEEEauthorblockA{NICTA\\\url{michael.norrish@nicta.com.au}}
%%2009-02-18%\and
%%2009-02-18%\IEEEauthorblockN{Tom Ridge}\IEEEauthorblockA{University of Cambridge\\\url{Thomas.Ridge@cl.cam.ac.uk}}
%%2009-02-18%\and
%%2009-02-18%\IEEEauthorblockN{Peter Sewell}\IEEEauthorblockA{University of
%%2009-02-18%  Cambridge\\\url{Peter.Sewell@cl.cam.ac.uk}}
%%2009-02-18%}
%%2009-02-18%\date{\today}
%%2009-02-18%\title{Abstracting TCP: a stream-level specification}
%%2009-02-18\maketitle
%%2009-02-18
%%2009-02-18\begin{abstract}
%%2009-02-18
%%2009-02-18Despite more then 30 years of research on protocol
%%2009-02-18specification, the major protocols deployed in the Internet, such as TCP,
%%2009-02-18are described only in informal prose RFCs and executable code.
%%2009-02-18In part this is because the scale and complexity of these protocols
%%2009-02-18makes them challenging targets for formalization.
%%2009-02-18
%%2009-02-18\ \ \ In this paper we show how these difficulties can be addressed.
%%2009-02-18%show how such real-world protocols can be addressed
%%2009-02-18%formally.
%%2009-02-18We
%%2009-02-18develop a high-level specification for TCP and the
%%2009-02-18Sockets API, expressed in the HOL proof assistant, describing the byte-stream
%%2009-02-18service that TCP provides to users.  This complements our previous
%%2009-02-18low-level specification of the protocol internals,
%%2009-02-18and makes it possible for the first time to state what it means for
%%2009-02-18TCP to be correct: that the protocol implements the service.
%%2009-02-18%
%%2009-02-18%
%%2009-02-18We
%%2009-02-18define a precise abstraction function between the models and validate
%%2009-02-18it by testing, using verified testing infrastructure within HOL.
%%2009-02-18%
%%2009-02-18This is a pragmatic alternative to full proof, providing reasonable
%%2009-02-18confidence at a relatively low entry cost.
%%2009-02-18%Proving such a result would be a very major undertaking, so instead
%%2009-02-18%
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18\ \ \ Together with our previous validation of the low-level model, this shows how one can rigorously tie together
%%2009-02-18concrete implementations,
%%2009-02-18low-level protocol models,
%%2009-02-18and specifications of the services they claim to provide, dealing with the complexity of
%%2009-02-18real-world protocols throughout.
%%2009-02-18
%%2009-02-18% ------------------------------
%%2009-02-18%
%%2009-02-18% % ?
%%2009-02-18% % internal/external
%%2009-02-18% % implementor's/user's
%%2009-02-18% %
%%2009-02-18% % don't really like "implentor's" and "users's"  words
%%2009-02-18% %
%%2009-02-18% FIXME doing for real hairy protocol
%%2009-02-18%
%%2009-02-18% Protocols and the service they provide are usually described in
%%2009-02-18% informal prose RFCs.
%%2009-02-18% In previous work
%%2009-02-18% % \cite{TCP:paper,TCP:POPLpaper} %[SIGCOMM'05, POPL'06]
%%2009-02-18% % don't write the cites like that in the actual paper, only in the
%%2009-02-18% % web-form abstract!
%%2009-02-18% we developed a formal low-level protocol
%%2009-02-18% model of TCP in HOL, in terms of individual TCP segments on the wire.
%%2009-02-18%
%%2009-02-18% A network protocol, such as TCP, can be viewed at three levels: the
%%2009-02-18% high-level \emph{service} that it provides to applications, the
%%2009-02-18% low-level \emph{protocol} that implements that service, and the
%%2009-02-18% \emph{realisation} of that protocol in endpoint implementation code.
%%2009-02-18% %
%%2009-02-18% In previous work
%%2009-02-18% % \cite{TCP:paper,TCP:POPLpaper} %[SIGCOMM'05, POPL'06]
%%2009-02-18% % don't write the cites like that in the actual paper, only in the
%%2009-02-18% % web-form abstract!
%%2009-02-18% we developed a low-level protocol
%%2009-02-18% model of TCP, in terms of individual TCP segments on the wire.
%%2009-02-18% %
%%2009-02-18% In this paper we develop a companion high-level service specification
%%2009-02-18% in terms of reliable byte streams.
%%2009-02-18% %
%%2009-02-18% Further, we define a precise abstraction function between the two specifications,
%%2009-02-18% explaining \emph{how} the protocol implements the service.
%%2009-02-18% %, mapping low-level states onto high-level streams.
%%2009-02-18% %
%%2009-02-18% We establish confidence by experimentally validating both specifications, and the abstraction
%%2009-02-18% function, against representative traces of the
%%2009-02-18% BSD implementation.
%%2009-02-18%
%%2009-02-18% Protocols and the service they provide are usually described in
%%2009-02-18% informal prose RFCs.
%%2009-02-18% %
%%2009-02-18% We use higher-order logic supported by the HOL theorem prover to
%%2009-02-18% provide a formal mechanized specification, abstraction function, and
%%2009-02-18% validation infrastructure.
%%2009-02-18% %
%%2009-02-18% The service specification can be used for (informal and formal)
%%2009-02-18% reasoning about applications above the Sockets API.
%%2009-02-18% %
%%2009-02-18% Moreover, for the first time it is possible to state precisely what it means for TCP to be correct: that the protocol implements the service.
%%2009-02-18%
%%2009-02-18% We thereby show how one can rigorously tie together
%%2009-02-18% concrete implementations,
%%2009-02-18% low-level protocol models,
%%2009-02-18% and specifications of the services they claim to provide, dealing with the complexity of
%%2009-02-18% real-world protocols throughout.
%%2009-02-18
%%2009-02-18\end{abstract}
%%2009-02-18
%%2009-02-18%\tableofcontents
%%2009-02-18
%%2009-02-18%FIXME correctness of TCP- be precise about what this is (not timeliness, stability of net etc.)
%%2009-02-18
%%2009-02-18%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Real-world network protocols %and the services they provide
are usually described in
informal prose RFCs, which inevitably have unintentional ambiguities and omissions,
and which do not support conformance testing,
%
verification of implementations, or verification of applications that use
these protocols.
%
Moreover, there are many subtly different realisations, including
the TCP implementations in BSD, Linux, WinXP, and so on.
%
The Internet protocols have been extremely successful, but the cost is high: there is considerable legacy complexity
%embodied in the protocols (and the services they provide) that
that
implementors and users have to deal with, and there is no clear point
of reference.
%
To address this, we have developed techniques to put practical
protocol design on a rigorous footing, to make it possible to specify
protocols and services with mathematical precision, and to do verified
conformance testing directly against those specifications.
%
In this work we demonstrate our approach by developing and validating
a high-level specification of the service provided by TCP:
the dominant data transport protocol (underlying email and the web),
which provides reliable duplex byte streams, with congestion control, above the unreliable IP layer.



Our specification deals with the full complexity of the service
provided by TCP (except for performance properties).  It includes the
Sockets API (\texttt{connect}, \texttt{listen}, etc.), hosts, threads, network interfaces, the
interaction with ICMP and UDP, abandoned connections, transient and
persistent connection problems, unexpected socket closure, socket
self-connection and so on.
%
The specification comprises roughly 30\,000 lines of (commented)
higher-order logic, and mechanized tool support has been essential for
work on this scale. It is written using the HOL system
\cite{hol:brief}.  The bulk of the definition is an operational
semantics, using idioms for timed transition relations,
record-structured state, pattern matching and so on.


We relate this service-level specification to our previous protocol
description by defining, again in HOL, an abstraction function
from the (rather complex) low-level protocol states, with sets of TCP
segments on the wire, flow and congestion control data, etc.,  to the (simpler)
service-level states, comprising byte streams and some status  information.  This makes explicit how
the protocol implements the service.



The main novelty of the approach we take here is the \emph{validation}
of this abstraction function.
Ideally, one would \emph{prove} that the abstraction relationship holds in
all reachable states.
Given the scale and complexity of the specifications, however, it is unclear
whether that would be pragmatically feasible, especially with the
limited resources of an academic team.
%
Accordingly, we show how one can validate the relationship by verified testing.
We take traces of the protocol-level specification (themselves
validated against the behaviour of the BSD TCP implementation), and
verify (automatically, and in HOL) that there are corresponding traces of the service-level
specification, with the abstraction function holding at each point.
%
Our previous protocol-level validation, using a special-purpose
symbolic evaluator, produced symbolic traces of the protocol-level
specification.  We now \emph{ground} these traces, using a
purpose-built constraint solver to instantiate
variables to satisfy any outstanding constraints, and use a new
symbolic evaluator to apply the abstraction function and check that
the resulting trace lies in the service-level specification.
By doing this all within HOL, we have high confidence in the
validation process itself.

Obviously, such testing cannot provide complete guarantees, but our
experience with the kind of errors it detects suggests that it is
still highly discriminating (partly due to the fact that it
examines the internal states of the specifications at every step along a
trace) and one can develop useful levels of confidence relatively
quickly.






%
% --- the other inclusion
%
% Moreover, HOL provides powerful machinery, including proof search and
% simplification, which we use to construct verified conformance
% checking code in HOL, providing strong formal guarantees about the
% results of validation. The checker uses novel symbolic evaluation
% techniques, incorporating purpose built constraint solvers we
% developed ourselves. The constraint solvers are also used to
% instantiate the partial traces which result from real-world testing,
% permitting much quicker validation of the service-level, compared to
% our previous protocol-level work. Furthermore, the existing results of
% protocol-level validation are lifted to the service-level via the
% abstraction function, further reducing the effort of service-level
% validation.
%
%
%
%
% Moreover, it might end up as an
% all-or-nothing endeavour:
%
% that would be a very major undertaking
%
% Whether such a proof is pragmatically feasible is an open queation
%
%
%
% contribution of this work, apart from the service-level
% specification itself
%
%
%
%
%
%
% We explain how the protocol implements the service by defining, again
% in HOL, an abstraction function from one to the other, simultaneously
% establishing the service specification as a statement of correctness
% for the protocol level.
%
%
% The mathematical tools used are relatively straightforward operational
% semantics:
%
% Our main definition is phrased as a standard operational semantics,
% extended to treat real-world features such as timers. It
% %FIXME need a list of all the horrible details
% %
% Mechanization, using the HOL theorem prover, makes such large scale
% formalization possible.
% %
%
% Our specific contributions are:
% \begin{itemize}
%
% %reasons for doing it: foundation for formal reasoning, statement of
% %correctness, case study in rigorous methodology, tie together
% %specifications (rather than develop a single spec), conformance
% %testing?, abstraction explains how, application programmers have clear
% %view of service
%
% \item We give a formal mechanized HOL specification of the service TCP provides, in terms of end-to-end byte stream behaviour and the Sockets API, thereby demonstrating rigorous specification of the service provided by a real-world protocol.
%
% \item We explain how the protocol implements the service by giving an abstraction function from one to the other, simultaneously establishing the service specification as a statement of correctness for the protocol level.
%
% \item We construct powerful verified testing infrastructure to validate real-world traces against both specifications and the abstraction function, and apply it to a small number of representative traces of the BSD TCP implementation, thereby giving confidence in the accuracy of our work.
%
% \end{itemize}

In the following sections, we first recall our previous protocol
model (Sect. \ref{sect:packet}), before describing the new service-level
specification (Sect. \ref{sect:stream}) and abstraction function
(Sect. \ref{sect:abstraction}), giving small excerpts from
each. We then discuss the validation infrastructure, and the results
of validation (Sect. \ref{sect:validation}). Finally, we discuss
related work and conclude.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background: our previous low-level protocol model} \label{sect:packet}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%following from ../paper.tex


%
Our previous low-level
specification~\cite{TCP:paper,TCP:POPLpaper} characterises TCP, UDP
and ICMP at the protocol level, including
hosts, threads, the Sockets API, network interfaces and segments on
the wire.
%
As well as the core functionality of segment retransmission and flow
control, TCP
must handle details of connection setup and tear-down, window scaling,
congestion control, timeouts, optional TCP features negotiated at
connection setup, interaction with ICMP messages, and so on.
%
The model covers all these.
%It is mainly based on the C source code for the BSD
%implementation, the source code for other implementations, and
%RFCs.
It is parameterized by the OS, allowing OS-dependent
behaviour to be specified cleanly; it is also non-deterministic, so as
not to constrain implementations unnecessarily.


This level of detail results in a model of roughly
30\,000 lines of (commented) higher-order logic (similar in size to the implementations, but structured rather differently).
As further evidence of its accuracy and completeness, it
has been successfully used as the basis for a Haskell
implementation of a network stack~\cite{DBLP:conf/pldi/LiZ07}.
%

The main part of the protocol model (the pale shaded region below) is
the \emph{host labelled transition system}, or \emph{host LTS},
describing the possible interactions of a host OS: between program
threads and host via calls and returns of the Sockets API, and between
host and network via message sends and receives.
%
The protocol model uses the host LTS, and a model of the TCP, UDP and
ICMP segments on the wire, to describe a network of communicating hosts.

%\begin{figure*}[t]
%\[
\vspace{1mm}
\hspace{7mm}
\input{endpoint.pstex_t}
%\]
%\caption{Protocol endpoint model}\label{b102}%
%\end{figure*}%







\newcommand{\labelA}{$ \MLhcall{\tsvar{tid}}{\tslib{bind}(\tsvar{fd},\tsvar{is}_{1},\tsvar{ps}_{1})} $}
\newcommand{\labelB}{$ \MLhreturn{\tsvar{tid}}{\tsvar{v}} $}
\newcommand{\labelC}{$ \MLhrecvdatagram{\tsvar{msg}} $}
\newcommand{\labelD}{$ \MLhsenddatagram{\tsvar{msg}} $}
\newcommand{\labelE}{$ \MLhtau  $}
\newcommand{\labelF}{$ \Meps{\tsvar{dur}} $}
%
\noindent
%The host LTS defines a transition relation
%$ \tsvar{h} \inp{\tsvar{lbl}} \tsvar{h}'$,
%where [[h]] and [[h']] are host states,
%modelling the relevant parts of the OS and network hardware of a single
%machine, and [[lbl]] is an interaction on
%either the Sockets API or wire interface.
%Typical  labels for a host making a transition $ \tsvar{h} \inp{\tsvar{lbl}} \tsvar{h}'$ are:
%\newcommand{\foohack}{\rule{0pt}{3ex}}
%\begin{tightlist}
%\item \labelC{}  \foohack{}for the host receiving a datagram [[msg]]
%  from the network, and
% \labelD{} \foohack{}for corresponding send;
%%\item \labelD{} \foohack{}for the host sending a datagram [[msg]] to the network;
%\item \labelA{} \foohack{}for a [[bind()]] call being made to the Sockets API by thread
%[[tid]], with arguments [[(fd,is1,ps1)]] for the file descriptor, IP
%address, and port;
%\item \labelB{}  \rule{0pt}{3ex}for value [[v]] being returned to
%thread [[tid]] by the Sockets API;
%\item \labelE{}  \foohack{}for an internal transition by the host, \eg for a datagram
%being taken from the host's input queue and processed, possibly
%enqueuing other datagrams for output; and
%\item \labelF{}  \foohack{}for time [[dur]] passing.
%\end{tightlist}
%%A sample trace of these labels is shown in
%%Fig.~\ref{fig:exampleTrace}.  It corresponds roughly to the union of a
%%packet-level trace and a system-call trace.

%%\begin{figure}
%%\input{trace0963.tex}
%%\vspace*{-10mm}
%%\caption{Example trace} \label{fig:exampleTrace}
%%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t]
\input{Spec1_send3.tex}
\scalebox{0.83}{
\begin{minipage}{\columnwidth}
% don't display definition description with defn
\renewcommand{\rrulecc}[9]{%
%  \rrenbox{%
    \rrulefront{#1}{#2}{#3}{#4}{#5}{#6}{#7}%
    \vspace*{1\baselineskip}%
    \rrenside{#8}%
%  }%
  %\rulecomment{#9}%
}%
%
\showrule{\specITsendTIII}%
\end{minipage}
}
\myheading{HOL syntax} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%FIXME formatting of excerpted text in following
%
%
For optional data items, $*$ denotes absence (or a zero IP or
port) and $\Msome  \;\tsunknown{x}$ denotes presence of value $\tsunknown{x}$.
%
Concrete lists are written $ [1,2,3] $ and appending two lists is
written using an infix $++$.
%
Records are written within angled brackets $\Mmagiclrec ...\Mmagicrrec $.
%
Record
fields can be accessed by dot notation or by
pattern-matching.
%
Record fields may be overridden: $\tsvar{cb}' = \tsvar{cb} \; \Mmagiclrec  \tsvar{irs} \Mass  \tsvar{seq} \Mmagicrrec $
states that the record $\tsvar{cb}'$ is the same as the record $\tsvar{cb}$,
except that field $\tsvar{cb}'.\tsvar{irs}$ has the value $\tsvar{seq}$.
%
The expression $\tsunknown{f} \oplus  [(\tsunknown{x},\tsunknown{y})] $ or $\Mfupdate{\tsunknown{f}}{\tsunknown{x}}{\tsunknown{y}}$ denotes the finite map $\tsunknown{f}$ updated
to map $\tsunknown{x}$ to $\tsunknown{y}$.

\caption{Protocol-level model, example rule} \label{fig:protocolRule}
\end{figure}

The host labelled transition relation, $ \tsvar{h} \inp{\tsvar{lbl}} \tsvar{h}'$, is defined by some 148 rules for the socket
calls (5--10 for each interesting call) and some 46 rules for message
send/receive and for internal behaviour.
%
%
An example of one of the simplest rules is given in
Fig.~\ref{fig:protocolRule}. The rule describes a host with a blocked
thread attempting to send data to a socket. The thread becomes
unblocked and transfers the data to the socket's send queue. The
send call then returns to the user.


The transition $\tsvar{h} \; \Mmagiclrec ... \Mmagicrrec
\Mtransition{\MLhtau }{1XXXXX\Mtransitionerr{-->}} \tsvar{h} \;
\Mmagiclrec ... \Mmagicrrec $ appears at the top, where the thread pointed
to by $\tsvar{tid}$ and the socket pointed to by $\tsvar{sid}$ are unpacked
from the original and final hosts, along with the send queue $\tsvar{sndq}$
for the socket. Host fields that are modified in the transition are
highlighted. The initial host has thread $\tsvar{tid}$ in state $\tscon{Send2}$,
blocking attempting to send $\tsunknown{str}$ to $\tsvar{sndq}$. After the transition,
$\tsvar{tid}$ is in state $\tscon{Ret} (\tscon{OK} ...)$, about to return to the user with
$\tsunknown{str''}$, the data that has not been sent, here constrained to be the
empty string.

The bulk of the rule is the condition (a predicate)
guarding the transition, specifying when the rule applies and what
relationship holds between the input and output states.  The condition
is simply a conjunction of clauses, with no temporal ordering.
%
The rule only applies if the state of the socket, $\tsvar{st}$, is either
$\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$.  Then, provided
$\tsaux{send\_queue\_space}$ is large enough, $\tsunknown{str}$ is appended to the $\tsvar{sndq}$ in the final host. Lastly, the urgent pointer
$\tsvar{sndurp}'$ is set appropriately.

%The protocol model can be combined with a model of messages on the
%wire, to give a network model, describing many hosts interacting over
%TCP.


Although the bulk of the model deals with the relatively simple Sockets
API, with many rules like that of Fig.~\ref{fig:protocolRule}, the real complexity arises from internal actions that are
largely invisible to the Sockets user, such as retransmission and
congestion control.  For example, the rule $\tsrule{deliver\_in\_3}$ (not shown) that handles normal
message receipt comprises over 1\,000 lines of higher-order logic.







The model has been validated against several thousand real-world
network traces, designed to test corner cases and unexpected
situations. Of these, 92\% are valid according to the model, and
we believe that for many purposes the model is sufficiently accurate
--- certainly enough to be used as a reference, in conjunction with
the standard texts.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The new service-level specification} \label{sect:stream}

%FIXME choices of what to abstract


The service-level specification, illustrated below, describes the behaviour of a network
of hosts communicating over TCP, as observed at the Socket
APIs of the connections involved.  It does not deal with TCP segments on the
wire (though it necessarily does include ICMP and UDP messages).
\\

\hspace{1cm}\input{endtoend.pstex_t}

In principle one could derive a service-level specification directly
from the protocol model, taking the set of traces it defines and
erasing the TCP wire segment transitions.  However, that would not
give a \emph{usable} specification: one in which key properties of
TCP, that users depend on, are clearly visible.
%
Hence, we built the service-level specification by hand, defining a
more abstract notion of host state, an abstract notion of stream
object, and a new network transition relation, but aiming to give the
same Sockets-API-observable behaviour.

The abstract host states are substantially simpler than those of the
protocol-level model.
For example, the protocol-level TCP control block contains 44 fields,
including retransmit and keep-alive timers; window sizes, sequence
position and scaling information; timestamping and round trip
times. Almost none of  these are relevant to the service-level
observable behaviour, and so are not needed in the service-level TCP control block.
%Similarly, the data for reassembly of out-of-order TCP segments is unnecessary.
%
Along with this, the transition rules that define the protocol dynamics, such as
$\tsrule{deliver\_in\_3}$, become much simpler.
The rules that deal with the Sockets API must be adapted to the new
host state, but they remain largely as before.  The overall
size of the specification is therefore not much changed, at around
30\,000 lines (including comments).



A naive approach to writing the individual rules would be to
existentially quantify those parts of the host state that are missing
at the service level (and then to logically simplify as much as
possible).  However, this would lead to a highly non-deterministic and
ultimately less useful specification.  Instead, we relied on a number
of invariants of the low-level model, arguing informally that, given
those, the two behaviours match.  We rely on the later validation to
detect any errors in these informal arguments.


% To limit non-determinism we employ
% knowledge of TCP invariants when constructing the service-level
% transitions. Since these invariants are informal, the process of
% writing a service-level transition involves an informal proof that,
% given the invariants, the service-level transition matches (according
% to the abstraction function) the behaviour of the protocol-level.
% %FIXME other inclusion whilst simultaneously limiting non-determinism as far as possible.
%
% ------------------------
%
%
%
%
%
%
% - dont' want trace-based spec
% - key invariants such as quue like beh not obvious
% - too big and complicated
%
%
% existentially quantifying over the host
% states and TCP wire segments.
%
%
% At the service level, the Sockets API user is shielded from most of the complex
% internal behaviour of TCP. To form the service-level specification, we
% therefore abstract over non-visible internal behaviour in the protocol
% model. This gives a conceptually simple specification, since internal
% behaviour accounts for the majority of the complexity of TCP. However,
% the large number of Sockets rules, which are largely shared between
% the service level and the protocol level, mean that the specification
% is still a large document, on roughly the same scale as our previous
% work and as the code. It captures the behaviour of the shaded region
% below.
% \\
%
% \hspace{1cm}\input{endtoend.pstex_t}
%
%
%
% Our first task is to decide how accurately we want to preserve the
% behaviour of the protocol level, and how much protocol-level state we
% want to replicate at the service level to support the desired level of
% accuracy.
% %
% This is far from straightforward. For example, at the protocol level
% we model host timers precisely, and consequently internal actions
% which affect timers, such as retransmission, may occasionally be
% revealed at the Sockets API through timing information. Since this
% behaviour breaks the stream abstraction, by revealing the presence or
% absence of underlying messages, we do not attempt to model this timing
% precisely. In the extremely unlikely event that an application relies
% on such properties, it will not be possible to verify it using the
% service specification, and the more complex protocol model must be
% used instead.
%
% A naive approach to writing the specification would then be to take an
% existing protocol transition and existentially quantify those parts of
% the host state that are missing at the service level. This leads to a
% highly non-deterministic and less useful specification. To
% limit non-determinism we employ knowledge of TCP invariants when
% constructing the service-level transitions. Since these invariants are
% informal, the process of writing a service-level transition involves
% an informal proof that, given the invariants, the service-level
% transition matches (according to the abstraction function) the
% behaviour of the protocol-level.
% %FIXME other inclusion whilst simultaneously limiting non-determinism as far as possible.



In the rest of this section we aim to give a flavour of the
service-level specification, the details of which are included in
later parts of this document.

% FIXME 44 fields v. 2 fields
%
% FIXME there is no explicit notion of stream at prot level
%
% conceptually simple from something very complicated


The heart of the specification is a model of a bidirectional TCP
connection as a pair of unidirectional byte streams between Sockets
endpoints:
%, where a unidirectional stream is represented as a HOL record:

%\enlargethispage{2\baselineskip}

\renewcommand{\defntcpStream}{\ddefnn{hackedtcpStream}{\iA{tcpStream}}{\subddefnA[{ unidirectional stream }]{tcpStream}{\tstype{tcpStream} = \Mmagiclrec {}{}
 \tsvar{i} : \tstype{ip};      \tsholcomm{ source IP }{}\\{}
 \tsvar{p} : \tstype{port};    \tsholcomm{ source port }{}\\{}
 \tsvar{flgs} : \tstype{streamFlags};{}\\{}
 \tsvar{data} : \tstype{byte} \;\tstype{list};{}\\{}
\hspace*{2.5mm}  \tsvar{destroyed} : \tstype{bool}{}  \Mmagicbolrrec
}
}
{}
}

\defntcpStream

The data in the stream is a byte list. Further fields record the
source IP address and port of the stream, control information in the
form of flags, and a boolean indicating whether the stream has been
destroyed at the source (say, by deleting the associated socket).
%
Some of these fields are shared with the low-level specification, but
others are purely abstract entities.
Note that although a stream may be destroyed at the source, previously
sent messages may still be on the wire, and might later be accepted
 by the receiver, so we cannot simply remove the stream when
it is destroyed. Similarly, if the source receives a message for a
deleted socket, a RST will typically be generated, which must be
recorded in the stream flags of the destroyed stream.
%
%Each stream has associated control information, modelling opening and
%closing of the stream. Hosts also maintain their own control
%information.
%
%
%Control information maintained by the streams is based closely on the
%protocol-level control information in segments in queues and on the wire.
%Thus, w
These flags record whether the stream is opening
($\tsvar{SYN}$,$\tsunknown{SYNACK}$), closing normally ($\tsvar{FIN}$) or abnormally ($\tsvar{RST}$).

\renewcommand{\defnstreamFlags}{\ddefnn{hackedstreamFlags}{\iA{streamFlags}}{\subddefnA[{ stream control information }]{streamFlags}{\tstype{streamFlags} = \Mmagiclrec {}{}
 \tsvar{SYN} : \tstype{bool};    \tsholcomm{ $\tsvar{SYN}$, no $\tsunknown{ACK}$ }{}\\{}
 \tsvar{SYNACK} : \tstype{bool}; \tsholcomm{ $\tsvar{SYN}$ with $\tsunknown{ACK}$ }{}\\{}
 \tsvar{FIN} : \tstype{bool};{}\\{}
\hspace*{2.5mm}  \tsvar{RST} : \tstype{bool}{}  \Mmagicbolrrec
 }
}
{}
}

\defnstreamFlags

This control information is carefully abstracted from the protocol
level, to capture just enough structure to express the user-visible
behaviour. Note that the $\tsvar{SYN}$ and $\tsunknown{SYNACK}$ flags may be set
simultaneously, indicating the presence of both kinds of message on
the wire. The receiver typically lowers the stream $\tsvar{SYN}$ flag on
receipt of a $\tsvar{SYN}$: even though messages with a $\tsvar{SYN}$ may still be
on the wire, subsequent $\tsvar{SYN}$s will be detected by the
receiver as invalid duplicates of the original.
%
A bidirectional stream is then just an unordered pair (represented as
a set) of unidirectional streams.

%\defntcpStreams

The basic operations on a byte stream are to read and write data. The
following defines a write from Sockets endpoint
$(\tsvar{i}_{1},\tsvar{p}_{1})$ to endpoint $(\tsvar{i}_{2},\tsvar{p}_{2})$.

\renewcommand{\defnwrite}{\ddefnn{hackedwrite}{\iA{write}}{\subddefnA[{ write flags and data to a stream }]{write}{\tsaux{write} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) (\tsvar{flgs},\tsvar{data}) \tsunknown{s} \;\tsunknown{s'} = ({}\\{}
\quad \exists  \tsunknown{in\_} \;\tsvar{out} \;\tsvar{in}' \;\tsvar{out}'.{}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s} (\tsunknown{in\_},\tsvar{out}) \Mwedge {}\\{}
\quad \tsaux{sync\_streams} (\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2}) \tsunknown{s'} (\tsvar{in}',\tsvar{out}') \Mwedge {}\\{}
\quad \tsvar{in}' = \tsunknown{in\_} \Mwedge {}\\{}
\quad \tsvar{out}'.\tsvar{flgs} ={}\\{}
\quad \Mmagiclrec   \tsvar{SYN} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{SYN} \Mvee  \tsvar{flgs}.\tsvar{SYN});{}\\{}
 \tsvar{SYNACK} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{SYNACK} \Mvee  \tsvar{flgs}.\tsvar{SYNACK});{}\\{}
 \tsvar{FIN} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{FIN} \Mvee  \tsvar{flgs}.\tsvar{FIN});{}\\{}
\hspace*{2.5mm} \tsvar{RST} \Mass  (\tsvar{out}.\tsvar{flgs}.\tsvar{RST} \Mvee
 \tsvar{flgs}.\tsvar{RST}){}  \Mmagicbolrrec  \Mwedge {}\\{}
\quad \tsvar{out}'.\tsvar{data} = (\tsvar{out}.\tsvar{data} ++ \tsvar{data}))}
}
{}
}

\defnwrite

Stream $\tsunknown{s'}$ is the result of writing $\tsunknown{flgs}$ and $\tsvar{data}$ to stream $\tsunknown{s}$.
%
Stream $\tsunknown{s}$ consists of a unidirectional input stream $\tsunknown{in\_}$
% (\textbf{in} is a reserved word)
and
 output stream $\tsunknown{out}$, extracted from the bidirectional
stream using the auxiliary $\tsaux{sync\_streams}$ function.
%
Similarly $\tsunknown{s'}$, the state of the stream after the
write, consists of $\tsunknown{in'}$ and $\tsunknown{out'}$.
%
Since we are writing to the output stream, the input stream
remains unchanged, $\tsunknown{in'} = \tsunknown{in\_}$. The flags on the output stream are
modified to reflect $\tsunknown{flgs}$. For example, $\tsvar{SYN}$ is set in
$\tsunknown{out'}.\tsunknown{flgs}$ iff $\tsunknown{flgs}$ contains a $\tsvar{SYN}$ or $\tsunknown{out}.\tsunknown{flgs}$ already
has $\tsvar{SYN}$ set. Finally, $\tsunknown{out'}.\tsvar{data}$ is updated by appending $\tsvar{data}$ to $\tsunknown{out}.\tsvar{data}$.
%
%The format of [[read]] is very similar to [[write]], but with the
%addition of a [[peek]] flag for reads that do not
%remove data from the stream.

Fig. \ref{fig:serviceRule} gives the service-level analogue
of the previous protocol-level rule.
The transition occurs between triples $(\tsvar{h} \; \Mmagiclrec  ... \Mmagicrrec , S_0 \oplus  [...],\tsunknown{M})$,
each consisting of a host, a finite map from stream identifiers to streams, and a set of UDP and ICMP
messages. The latter do not play an active part in
this rule, and can be safely ignored.
%
Host state is unpacked from the host as before. Note that
protocol-level constructs such as $\tsvar{rcvurp}$ and $\tsvar{iobc}$ are absent
from the service-level host state. As well as the host transition,
there is a transition of the related stream $\tsunknown{s}$ to $\tsunknown{s'}$. The
stream is unpacked from the finite map via its unique identifier
$\tsaux{streamid\_of\_quad}(\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2})$, derived from its quad.

\input{Spec3_send3.tex}
\newcommand{\hackhackhack}[1]{}  % For Tom
\begin{figure}[t]
% don't display definition description with defn
\renewcommand{\rrulecc}[9]{%
%  \rrenbox{%
    \rrulefront{#1}{#2}{#3}{#4}{#5}{#6}{#7}%
    \vspace*{1\baselineskip}%
    \rrenside{#8}%
%  }%
  %\rulecomment{#9}%
}%
%
\scalebox{0.83}{
\begin{minipage}{\columnwidth}
\showrule{\hackedsendTIII}%
\end{minipage}
}
\caption{Service-level specification, example rule} \label{fig:serviceRule}
\end{figure}


As before, the conditions for this rule require that the state of the
socket $\tsvar{st}$ must be $\tscon{ESTABLISHED}$ or $\tscon{CLOSE\_WAIT}$.
%
Stream $\tsunknown{s'}$ is the result of writing
string $\tsunknown{str'}$ and flags $\tsunknown{flgs}$ to $\tsunknown{s}$. Since $\tsunknown{flgs}$ are all false, the write does not cause any
control flags to be set in $\tsunknown{s'}$, although they may already be set in
$\tsunknown{s}$ of course.

This rule, and the preceding definitions, demonstrate the conceptual
simplicity and stream-like nature of the service level.
%
Other interesting properties of TCP are clearly captured by the
service-level specification. For example, individual writes do not
insert record boundaries in the byte stream, and in general, a read
returns only part of the data, uncorrelated with any particular write.
%
The model also makes clear that the unidirectional streams are to a
large extent independent. For example, closing one direction does not
automatically cause the other to close.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The abstraction function} \label{sect:abstraction}

 \begin{figure*}[t]
 \[
 \hspace{-.0cm}\scalebox{0.48}{\input{absFunCommute6.pstex_t}}
 \]

 \caption{Abstraction function, illustrated (data part only)}\label{fig:absFun3}%
 \end{figure*}%

%\begin{figure}
%\begin{center}\input{absFunCommute3.pstex_t}\end{center}
%\caption{Abstraction function} \label{fig:absFun3}
%\end{figure}


% \begin{figure*}[t]
% \[
% \scalebox{0.5}{\input{absFunCommute2.pstex_t}}
% \]
% This illustrates the abstraction function.  The bottom (concrete) half
% shows a transition between two concrete network states, labelled by a
% $\mathrm{send}(\texttt{xyz})$ on host $h_1$, with the send and receive
% queues of each host and the TCP segments on the wire.  The top
% (abstract) half shows the corresponding abstract network states, with
% the logical stream objects.  Only the data part is shown; the more
% intricate Socket states, TCBCBs, control flags, etc., are elided.
%
% \caption{Abstraction Function}\label{fig:absFunCommute}%
% \end{figure*}%

While the service specification details \emph{what} service an
implementation of TCP provides to the Sockets interface, the
abstraction function details \emph{how}.
%
% first appearance of the "network", hitherto it has all been hosts
%
The abstraction function maps protocol-level states and transitions
to service-level states and transitions.  A
protocol-level network consists of a set of hosts, each with their own
TCP stacks, and segments on the wire.
The abstraction function takes this data and calculates abstract byte
streams between Sockets API endpoints, together with the  abstract
connection status information.


The latter is the more intricate part, but we can give only a simple
example here:
%the
%stream [[RST]] flag is set iff a [[RST]] segment appears in the
%messages in protocol-level host queues or on the wire;
the
$\tsunknown{destroyed}$ flag is set iff either there is no socket on the
protocol-level host matching the quad for the TCP connection or the
state of the TCP socket is $\tscon{CLOSED}$.

\input{Spec3_abs_hosts_one_sided}
\begin{figure}
% don't display definition description with defn
\renewcommand{\ddefnn}[4]{%
%  \rrenbox{%
    \dodefnindex{#2}%
    \ltslabel{#1}%
    \rrenside{#3}%
%  }%
}
\scalebox{0.75}{
\begin{minipage}{\columnwidth}
%\begin{multicols}{2}
\hackeddefnabsThostsToneTsided
%\end{multicols}
\end{minipage}
}
\caption{Abstraction function, excerpt}\label{fig:absFunHOL}%
\end{figure}%


The former is illustrated in Fig.~\ref{fig:absFun3}.
%
% At the service level, the TCP
% stacks and the segments on the wire are replaced by byte streams
% between Sockets endpoints.
% %
% The abstraction function constructs two things:
% the abstract data streams and the
% connection status information
%
% from the low-level
% segments on the wire and queues within hosts,
%
% thereby explains how streams
% arise from the data in endpoint states and segments on the wire,
%
% %The abstraction function is built on a unidirectional abstraction
% %function. Given a source and destination host at the protocol level,
% %a set of messages on the wire, and a quad for the TCP
% %connection, the unidirectional abstraction function constructs a
% %unidirectional stream representing the connection identified by the
% %quad.
%
For example, consider the simple case where communication has already been established, and the source is sending a
message to the destination that includes the string
``\texttt{abc...xyz}'', of which bytes up to ``\texttt{w}'' have been
moved to the source $\tsvar{sndq}$. Moreover, the destination has
acknowledged all bytes up to ``\texttt{f}'', so that the $\tsvar{sndq}$
contains ``\texttt{fgh...uvw}'', and $\tsfield{snd\_una}$ points to
``\texttt{f}''. The destination $\tsvar{rcvq}$ contains
``\texttt{cde...opq}'', waiting for the user to read from the socket,
and $\tsfield{rcv\_nxt}$ points just after ``\texttt{q}''.
%
%\begin{verbatim}
%                 |         snd_una     rcv_nxt
%seq num ---------+---------+-----------+-----------
%message          | ...abcdefghijklmnopqrstuvwxyz...
%source sndq      |         fghijklmnopqrstuvw
%destination rcvq |      cdefghijklmnopq
%stream contents  |      cdefghijklmnopqrstuvw
%\end{verbatim}
%
%
\par\noindent{\small
\tt\begin{center}
\begin{tabular}{|l|c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}c@{}|}
\hline
                               & & & & & & & & &$\downarrow$&\multicolumn{10}{l}{\textrm{$\tsfield{snd\_una}$}} & &$\downarrow$&\multicolumn{10}{l}{\textrm{$\tsfield{rcv\_nxt}$}}  &\\ \hline
{\textrm{message}}             &.&.&.&a&b&c&d&e&f&g&h&i&j&k&l&m&n&o&p&q&r&s&t&u&v&w&x&y&z&.&.&.\\ \hline
{\textrm{source $\tsvar{sndq}$}}     & & & & & & & & &f&g&h&i&j&k&l&m&n&o&p&q&r&s&t&u&v&w& & & & & & \\ \hline
{\textrm{destination $\tsvar{rcvq}$}}& & & & & &c&d&e&f&g&h&i&j&k&l&m&n&o&p&q& & & & & & & & & & & & \\ \hline
{\textrm{$\tsaux{DROP} (\tsfield{rcv\_nxt} - \tsfield{snd\_una}) \tsvar{sndq}$}}   & & & & & & & & & & & & & & & & & & & & &r&s&t&u&v&w& & & & & & \\ \hline
{\textrm{stream}}     & & & & & &c&d&e&f&g&h&i&j&k&l&m&n&o&p&q&r&s&t&u&v&w& & & & & & \\ \hline
\end{tabular}\end{center}
}
%\\

The data that remains in the stream waiting for the destination
endpoint to read, is the byte stream ``\texttt{cdefghijklmnopqrstuvw}''. This is
simply the destination $\tsvar{rcvq}$ with part of the source $\tsvar{sndq}$
appended: to avoid duplicating the shared part of the byte sequence,
$(\tsfield{rcv\_nxt} - \tsfield{snd\_una})$ bytes are dropped from $\tsvar{sndq}$ before
appending it to $\tsvar{rcvq}$.

An excerpt from the HOL definition appears in Fig. \ref{fig:absFunHOL}.
%
It takes a quad
$(\tsvar{i}_{1},\tsvar{p}_{1},\tsvar{i}_{2},\tsvar{p}_{2})$ identifying the TCP connection, a source host $\tsvar{h}$,
a set of messages $\tsunknown{msgs}$ on the wire, and a
destination host $\tsunknown{i}$, and produces a unidirectional stream.
%
It follows exactly the previous analysis: $(\tsfield{rcv\_nxt} - \tsfield{snd\_una})$
bytes are dropped from $\tsvar{sndq}$ to give $\tsvar{sndq}'$, which is then
appended to $\tsvar{rcvq}$ to give the data in the stream.

Note that, in keeping with the fact that TCP is designed so that hosts
can retransmit any data that is lost on the wire, this abstraction
does not depend on the data in transit --- at least for normal
connections in which neither endpoint has crashed.

For a given TCP connection, the full abstraction function uses the
unidirectional function twice to form a bidirectional stream
constituting the service-level state.
%
As well as mapping the states, the abstraction function maps the
transition labels. Labels corresponding to visible actions at the
Sockets interface, such as a \texttt{connect} call, map to
themselves. Labels corresponding to internal protocol actions, such as
the host network interface sending and receiving datagrams from the
wire, are invisible at the service level, and so are mapped to $\tau$,
indicating no observable transition.
%
Thus, for each protocol-level transition, the abstraction function
gives a service-level transition with the same behaviour at the
Sockets interface. Mapping the abstraction function over a
protocol-level trace gives a service-level trace with identical
Sockets behaviour. Every valid protocol-level trace should map to a
valid service-level trace.

%FIXME really need to nail down where the correctness of TCP comes into
%the abstraction function... point is that read and write have no
%knowledge of the TCP sequence counters, but it turns out that they
%interact with the abstraction function in a reasonable way.

%FIXME talk about the semantics of the abstraction function ``there is
%a msg on the wire which may be received as valid by the endpoint,
%st....'', which involves talking about the SYN errors in Spec1, and
%why we duplicate these errors in Spec3 (to preserve admissible
%traces). (?)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental validation} \label{sect:validation}


How can we ensure that TCP implementations (written in C), our
previous protocol-level model (in HOL), and our new service-level
specification (also in HOL) are consistent?
%
Arguing
that a small specification corresponds to a simple real-world system
can already be extremely challenging. Here, we are faced with very large
specifications and a very complex real-world system.
%
Ideally one would verify the relationship between the protocol and
service specifications by proving that their behaviours correspond,
%i.e.~that
%every valid trace
%at the protocol-level maps to a valid trace at the service-level. This proof would
making use of the abstraction function.
%
One would also prove that the Sockets behaviour of the endpoint
implementations (formalized using a C semantics) conformed to the
protocol model.

Proving the relationships between the levels in this way would be a
very challenging task indeed. One of the main barriers is the scale of TCP
implementations, including legacy behavioural intricacies of TCP and
Sockets, which were not designed with verification in mind.
%This is
%reflected in the protocol model and, to a lesser extent, in the
%service-level specification.

Hence, we adopt the pragmatic  approach of
validating the specifications to provide reasonable confidence in
their accuracy.
Note that for TCP the implementations are the de facto standard.  In
producing specifications after the fact, we aim to validate the
specifications against the implementation behaviour. Our
techniques could equally well be used in the other direction for new protocol designs.
Our service-level validation builds on our earlier protocol-level
work~\cite{TCP:paper,TCP:POPLpaper}, so we begin by recalling that.

\myheading{Protocol-level validation}
We instrumented a test network and wrote tests to drive hosts on the
network, generating real-world traces.
%
We then ensured that the protocol specification admitted those traces by
running a special-purpose symbolic model checker in HOL, correcting
the specification, and iterating, when we discovered errors.
%
Because it is based directly on the formal specification, and deals
with all the internal state of hosts, the checker
is extremely rigorous, producing a machine checked proof of
admissibility for each successfully validated trace. Obviously
no testing-based method can be complete, but this found many issues in
early drafts of the specification, and also identified a number of
anomalies in TCP implementations.


\myheading{Service-level validation}
For the service-level validation, we began with a similar instrumented
test network, but collected double-ended traces, capturing
the behaviour of two interacting hosts, rather than just one endpoint.
%
We then used our previous symbolic evaluation tool to discover
symbolic traces of the protocol-level model that corresponded to the
real-world traces.
%
That is a complex and computationally intensive process,
involving backtracking depth-first search and constraint
simplification, essentially to discover internal host state and
internal transitions that are not explicit in the trace.

We then \emph{ground} these symbolic traces, finding instantiations of
their variables that satisfy any remaining constraints, to produce a
ground protocol-level trace in which all information is explicit.
%
Given such a ground trace, we can map the abstraction function
over it to produce a candidate ground service-level trace.

It is then necessary to check validity of this trace, which is done
with a service-level test oracle.
% This is analogous to the
%protocol-level symbolic evaluator, but, crucially can be much simpler.
%It need deal only with ground transitions, and each transition can be
%checked in isolation, so there is no need for a backtracking search.%
%
%---
%
As at the protocol level, we wrote a new special-purpose service-level
checker in HOL which performs symbolic evaluation of the specification
with respect to ground service-level traces. Crucially, this checking process is
much simpler than that at the protocol level because all host values,
and all transitions, are already known. All that remains is to check
each ground service-level transition against the specification.

% new MN stuff (following may not be appropriate for INFOCOM audience)
The most significant difference between the old and new checkers is
that the former had to perform a depth-first search to even determine
which rule of the protocol model was appropriate.  Because
that work has already been done, and because the two specifications
have been constructed so that their individual rules correspond, the
service-level checker does not need to do this search.  Instead, it can
simply check the service-level version of the rule that was checked at
the protocol level, dealing with each transition in isolation.  In particular, this means that the service-level
checker need not attempt to infer the existence of unobservable
$\tau$-transitions.

Another significant difference between the two checkers is that the
service-level checker can aggressively search for instantiations of
existentially quantified variables that arise when a rule's hypothesis
has to be discharged.  At the protocol level, such variables may appear
quite unconstrained at first appearance, but then become progressively
more constrained as further steps of the trace are processed.

For example, a simplified rule for the \texttt{socket} call might
appear as
% readers haven't seen inference rule style presentation of a rule before
\[
\infer{\tsvar{h}_{0} \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \Mmagicrrec  \inp{\MLhcall{\tsvar{tid}}{\tslib{socket}()} }
  \tsvar{h}_{0} \Mmagiclrec  \tsvar{socks} \Mass  \tsvar{socks} \oplus  (\tsvar{sid},\tsvar{fd})\Mmagicrrec % stream_spec.mng:1299:48-50:WARNING: Close delimiter without matching open.
}{
  \tsvar{fd}\not\in\textsf{usedfds}(\tsvar{h}_{0})}
\]
stating that when a \texttt{socket} call is made, the host $h_0$'s
\texttt{socks} map is updated to associate the new socket (identified
by $\mathit{sid}$) with file-descriptor $\mathit{fd}$, subject only
to the constraint that the new descriptor not already be in use.
(This under-specification is correct on Windows; on Unix, the
file-descriptor is typically the next available natural number.)

In the protocol-level checker, the $\tsvar{fd}$ variable must be left
uninstantiated until its value can be deduced from subsequent steps in
the trace.  In the service-level checker, both the initial host and the
final host are available because they are the product of the
abstraction function applied to the previously generated, and ground,
protocol trace.  In a situation such as this, the variable from
the hypothesis is present in the conclusion, and can be immediately
instantiated.

In other rules of the service-level specification, there can be a great
many variables that occur only in the hypothesis.  These are
existentially quantified, and the checker must determine if there is
an instantiation for them that makes the hypothesis true.  The most
effective way of performing this check is to simplify, apply decision
procedures for arithmetic, and to then repeatedly case-split on
boolean variables, and the guards of \textsf{if-then-else} expressions
to search for possible instantiations.


The above process is clearly somewhat involved, and itself would
ordinarily be prone to error.   To protect against this we built all
the checking infrastructure within HOL.  So, when checking a
trace, we are actually building
machine-checked proofs that its transitions are admitted by the
inductive definition of the transition relation in the specification.


\myheading{Results} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
Our earlier protocol-level validation involved several thousand
traces designed to exercise the behaviour of single endpoints,
covering both the Sockets API and the wire behaviour.   To produce a
reasonably accurate specification, we iterated the checking and
specification-fixing process many times.

For the service-level specification, we have not attempted the same
level of validation, simply due to resource constraints.
Instead, we have focused on developing the method, doing enough
validation to demonstrate its feasibility.
%
Producing a specification in which one should have high confidence
might require another man-year or so of testing --- perfectly
feasible, and a tiny amount of effort in terms of industrial protocol
stack development, but unlikely to lead to new research insights.
%
That said, most of the Sockets API behaviour does not
relate to the protocol dynamics and is common between the two
specifications, so is already moderately well tested.
%
%
%
%
%
%
%
% validated the service-level to nearly the same degree, largely because
% we are resource constrained. In particular, we have not attempted to
% generate traces involving packet loss, reordering, duplication,
% corruption and severe delay.
%
%
% As we describe in Sect. \ref{FIXME}, both protocol mdoel and service
% specification split into two parts, with the Sockets rules essentially
% shared.
% %
% Since extensive validation has taken place for the protocol-level
% Sockets rules, we chose to focus our effort on validating end-to-end
% behaviour at the service-level.
% %
% However, resource constraints mean we have not attempted to generate
% traces involving packet loss, reordering, duplication, corruption, and
% severe delay.  We return to this in the conclusion.
%
In all, 30 end-to-end tests were generated,
%
%60 unidirectional protocol-level
%traces, which were validated against the protocol model,
covering a
variety of connection setup and tear-down cases and end-to-end
communication, but not including packet loss, reordering, duplication,
and severe delay.
% For each of
% the real-world traces, the test oracle produced a corresponding ground
% protocol-level trace, containing full information about the state of
% the hosts and the transitions that occurred. We joined these
% unidirectional traces to produce 30 ground protocol-level network
% traces, which we mapped to a corresponding number of ground
% service-level network traces. These in turn were validated against the
% service-level specification using the service-level test oracle.
% %
After correcting errors, all these traces were found to validate
successfully.

To illustrate how discriminating our testing process is, we mention two errors we discovered during validation.
%
At the protocol-level, a TCP message moving from a host output queue
to the wire corresponds to an unobservable $\tau$ event at the service
level. Naively we assumed the host state would be unchanged, since the
output queue at the service-level carries only ICMP and UDP
messages. However, this is not correct, since the transmission of a
TCP message alters the timer associated with the output queue,
increasing its value. The update to the timer permits the host to
delay sending the ICMP and UDP messages. Without this side-effect, the
service-level specification effectively required ICMP and UDP messages
to be sent earlier than they would otherwise have been. To correct
this error, the service specification had to allow the timer to be
updated if at the protocol-level there was potentially a TCP message
on the queue that might be transferred to the wire.
%
Another error arose in the definition of the abstraction function. The
analysis of the merging of the send and receive queues on source and
destination hosts, described in Sect. \ref{sect:abstraction}, was
initially incorrect, leading to streams with duplicated, or missing,
runs of data. Fortunately this error was easy to detect by examining
the ground service-level trace, where the duplicated data was immediately apparent.

Our validation processes check that certain traces are included
in the protocol-level or service-level specification. As we have seen,
this can be a very discriminating test, but it does not  touch on the
possibility that the specifications admit too many traces. That cannot
be determined by reference to the de facto standard implementations, as a reasonable
specification here must be looser than any one implementation. Instead,
one must consider whether the specifications are strong enough to be
useful, for proving properties of applications that use the Sockets
API, or (as in \cite{DBLP:conf/pldi/LiZ07}) as a basis for new implementations.

%For example, the data stream would suddenly
%become doubled for no apparent reason. Such traces obviously do not
%conform to the service-level specification.

% We see no technical barrier to extending
% validation to these areas, but
% %
% there is good reason to believe that doing so would reveal very few
% errors. The end-to-end part of the specification is very abstract, and
% clearly captures the stream aspect of TCP. We have validated this
% under favourable network conditions. With packet loss, reordering, and
% so on, it is a fact of experience that TCP preserves end-to-end
% behaviour. Thus, service-level behaviour should not be affected by
% unfavourable network conditions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}

%our previous work, and optical stuff, and all the rest

%formal aspects of testing, Andreas Bauer
% he just moved to NICTA; web-page at
% http://users.rsise.anu.edu.au/~baueran/publications/index.html
% technique is run-time diagnosis - traces checked against LTL
% specifications; contribution is to come up with alternative
% definition of LTL so that it can give a verdict (definitely OK,
% definitely bad, don't know) given a finite trace (seen so far).
% (Issue is that LTL is defined wrt infinite traces, but at any given
% point, diagnoser only has access to finite prefix.)
%, check temporal logic props of traces- what is this reference? (can't find)


This work builds on our previous TCP protocol model
\cite{theTR,thespec,TCP:paper,TCP:POPLpaper}, and we refer the reader there for
detailed discussion of related work.
%
We noted that ``to the best of our knowledge, however, no previous work approaches a
specification dealing with the full scale and complexity of a
real-world TCP''.
%
This also applies to the service-level specification.
%
As before,  this is unsurprising: we have
depended on automated reasoning tools and on raw compute
resources that were simply unavailable in the 1980s or early 1990s.
Our goals have also been different, and in some sense more modest,
than the correctness theorems of traditional formal verification: we have not attempted to \emph{prove}
that an implementation of TCP satisfies the protocol model, or that
the protocol satisfies the service-level specification.

Since the protocol model was published, there have been several papers
extending our work in various directions. As part of his thesis on
massively concurrent applications in Haskell \cite{penglithesis}, Peng
Li translated the protocol specification to Haskell to produce an
executable user-space TCP stack. Compton verified Stenning's protocol
based on our UDP model \cite{DBLP:conf/cats/Compton05}. Subsequently
we verified an implementation of a persistent message queue based on a
model of TCP that, although different from the service-level
specification, was heavily influenced by it \cite{conf/popl/Ridge09}.


%Our \cite{BDJRS06} describes a successful application of our
%methodology to specify an optical networking protocol at design time.

There is a vast literature devoted to verification techniques for
protocols, with both proof-based and model checking approaches,
\eg in conferences such as CAV, CONCUR, FM, FORTE, ICNP, SPIN, and TACAS\@.
%
The most detailed rigorous specification of a TCP-like protocol we are aware of is that of
Smith \cite{Smi96short}, an I/O automata specification and
implementation, with a proof that one satisfies the
other, used as a basis for work on T/TCP\@.
The protocol is still substantially idealised, however.
Later work by Smith and Ramakrishnan uses a similar model to verify properties of a model of
SACK \cite{SR02}.
A variety of work addresses radically idealised variants of TCP
\cite{CHV03,FJ00,Sch96,HL00,BB03,55495,MS88}.
% For radically idealised variants of TCP, one has for example the PVS verification of an improved Sliding Window protocol by Chkliaev \etal \cite{CHV03},
% and
% Fersman and Jonsson's  application of the SPIN model checker to a
% simplified version of the TCP establishment/teardown handshakes
% \cite{FJ00}.
% Schieferdecker verifies a
% property (expressed in the modal $\mu$-calculus) of a LOTOS
% specification of TCP, showing that data is not received before it is
% sent \cite{Sch96}. The specification is again roughly at the level of the TCP state
% diagram.
% Hofmann and Lemmen report on testing of a protocol stack based on an
% SDL specification of TCP/IP \cite{HL00}.
% %
% Billington and Han have produced a coloured Petri net model of the
% service provided by TCP %(in our terminology, roughly an end-to-end specification),
% %but
% for a highly idealised ISO-style interface
% \cite{BB03}.
% %, and a highly idealised
% %model of transmission for a bounded-size medium
% %\cite{BB03,BB04}.
% %
% %
% Murphy and Shankar verify some safety properties of a 3-way handshake
% protocol analogous to that in TCP
% \cite{55495} and of a transport protocol based on this \cite{MS88}.
%
Finally, Postel's PhD thesis used early Petri net protocol models descriptively
\cite{Postel74}. %,Postel76}.


%Musuvathi and Engler have applied their CMC model checker to a Linux
%TCP/IP stack \cite{ME04}.
%%
%%Interestingly, they began by trying to work with just the TCP-specific
%%part of the codebase (\ie, the pure transport-protocol specification
%%described in \S\mref{b92}), but moved to working with the entire codebase
%%on finding the OS-internal TCP$\leftrightarrow$IP interface too complex.
%%
%The properties checked were of two kinds:  resource leaks and
%invalid memory accesses, and protocol-specific properties
%%. The latter
%%were
%specified by a hand translation of the RFC793 state diagram into
%C code.  While this is a useful model of the protocol, it is an extremely
%abstract view, omitting flow control, congestion control etc.

%In a rare application of rigorous techniques to actual standards,
%Bhargavan, Obradovic, and Gunter use a combination of the HOL proof
%assistant and the SPIN model checker to study properties of
%distance-vector routing protocols \cite{BOG02}, proving correctness
%theorems. The
%protocols are significantly simpler: their model of RIP is (by a nave
%line count) around 50 times smaller than the specification we present
%here.

%There are I/O automata specifications and proof-based
%verification for aspects of the Ensemble group communication system by
%Hickey, Lynch, and van Renesse \cite{HLR99}, and
%NuPRL proofs of fast-path optimizations for local Ensemble code by
%Kreitz \cite{Kre04}.


Implementations of TCP in high-level languages have been written by
Biagioni in Standard ML \cite{Bia94}, by Castelluccia \etal in Esterel
\cite{CDO97}, and by Kohler \etal in Prolac \cite{prolac:sigcomm99}.
As for any implementation, allowable non-determinism means
they cannot be used as oracles for conformance testing.



% work related to the abstraction function%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% P thinks this stuff is basically irrelevant
%
%Our present work includes an abstraction function from the protocol
%model to the service-level specification. Abstraction has been applied
%to reduce the state space in model checking
%\cite{conf/time/Clarke03}. Refinement is widely used to derive program
%implementations from mathematical specifications
%\cite{W48,WooDav96,Back-vonWright98}.

For concurrent and distributed systems, there are many
abstraction-refinement techniques, such as abstraction relations
(which include our abstraction function) and simulation relations, see
\cite{Lynch*95:Forward} for an overview.
%
As an example of these techniques, Alur and Wang address the PPP and
DHCP protocols \cite{AW01}. For each they check refinements between
models that are manually extracted from the RFC specification and from
an implementation.
%
Although these techniques are widely used in verification, to the best
of our knowledge, they have never been applied previously to
real-world protocols on the scale of TCP.


%\addcontentsline{toc}{chapter}{How to read the specification}
%\section*{How to read the specification}
\section{How to read the service-level specification}

This document is the third volume of a series. The first two volumes
describe the protocol-level specification.  For a full discussion of
the protocol-level specification we refer the reader to the companion
\emph{TCP, UDP and Sockets, Volume 1: Overview} \cite{theTR} and
especially to the section there titled ``The Specification ---
Introduction'', which gives a brief introduction to the HOL language
and to the structure of the model. The protocol-level specification
itself is detailed in \emph{TCP, UDP and Sockets, Volume 2: The
  Specification} \cite{thespec}.

The service-level is closely related to the protocol-level (as the
abstraction function makes clear), and the two specifications are
similar in many ways. For example, the service-level specification of
the host transition relation closely parallels that of the
protocol-level. The reader familiar with the syntax and format of the
protocol-level rules should find the service-level very
familiar. Therefore the overview of the protocol-level \cite{theTR} is
recommended as an introduction to the style and formalism employed in
the service-level specification.
%
We briefly summarize the main differences
between the HOL theory files of the two specifications.

\begin{itemize}
\item The service-level host types in Sect.~\ref{TCP3_hostTypes} are
  more abstract than those at the protocol-level. For example, a
  TCP control block contains 44 fields at the protocol level, compared with 2 at the service level.

\item The formal definition of byte streams in Sect.~\ref{TCP3_streamTypes} is not present at the protocol level.

\item The rule labels in Sect.~\ref{TCP3_host0} are essentially the
  same as those at the protocol level. Although the rule labels match,
  it is worth recalling that TCP datagram sends and receives at the
  protocol level will be replaced by stream interactions at the
  service level. The service-level datagram labels are primarily used
  for UDP and ICMP messages.

\item The auxiliary functions in Sect.~\ref{TCP3_auxFns} are
  similar to those at the protocol level.

\item The Sockets rules in Sect.~\ref{socket_calls} correspond
  one-to-one with those at the protocol level. For the most part they
  are minor simplifications of the corresponding protocol-level
  rules. The Sockets API embodies considerable complexity independent
  of the internal functioning of TCP, which is why these rules are not much simpler.

\item The interal functioning of TCP in Sect.~\ref{tcp_input_processing} and Sect.~\ref{tcp_output} is significantly simpler than
  that at the protocol level, because much of the detail of TCP, such
  as retransmission, has been abstracted away.

\item The behaviour of the byte-streams described in Sect.~\ref{TCP3_stream} is
  unique to the service-level specification.

\item The network model in Sect.~\ref{net_LTS} differs from the
  protocol level in that it includes additional stream objects, and
  transitions related to them.

\item The abstraction function in Sect.~\ref{absFun} ties the
  protocol-level and the service-level specifications together.

\end{itemize}

The rest of this document consists of the HOL specification
itself. This specification is organised as a reference (in
approximately the logical order in which it is presented to the HOL
system), not as a tutorial.
%
To read the specification one should first look at the key types used
(base types from the protocol level, the service-level host types, and
the stream types) and then browse the Host LTS Socket Call rules.

The service-level and the protocol-level specifications share common
theory infrastructure: the service-level specification imports all
protocol-level theories upto and including {\tt
  TCP1\_preHostTypes}. These theories are not duplicated here; they can
be found in the protocol-level specification \cite{thespec}.




\section{Project History}
%
In this section we summarise our previous work that led up to this TCP
specification, to put it in context.  All of these, and the HOL
theories for the main specifications, are available on-line\footnote{\url{http://www.cl.cam.ac.uk/~pes20/Netsem/index.html}}.

Our early work focussed just on UDP, ICMP,
and the Sockets API. The first technical report and TACS paper
describe a model without time, threads, or modules, and using informal
mathematics. The ESOP paper reports on a HOL version of the specification, extended to
cover those three aspects. The SIGOPS EW paper is a position paper
reflecting on the experience of this and of Norrish's C semantics
work.
\begin{itemize}
    \item The UDP Calculus: Rigorous Semantics for Real Networking. Technical report 515. Andrei Serjantov, Peter Sewell, and Keith Wansbrough. iv+70pp. July 2001.

    \item The UDP Calculus: Rigorous Semantics for Real Networking. Andrei Serjantov, Peter Sewell, and Keith Wansbrough. In TACS 2001, LNCS 2215, 535--559.

    \item Timing UDP: mechanized semantics for sockets, threads and
    failures. Keith Wansbrough, Michael Norrish, Peter Sewell, Andrei
    Serjantov. In ESOP 2002, LNCS 2305, 278--294.

%    \item Timing UDP: the HOL model. Here are the HOL scripts and a typeset version of the timed host semantics described in the paper above.

    \item Rigour is good for you and feasible: reflections on formal treatments of C and UDP sockets. Michael Norrish, Peter Sewell, Keith Wansbrough. In SIGOPS EW 2002, 49--53.
\end{itemize}
The following demonstrates the feasibility of completely formal reasoning (in the Isabelle proof assistant) about executable code in a fragment of OCaml above the UDP specification:
\begin{itemize}
    \item Stenning's Protocol Implemented in UDP and Verified in Isabelle. Michael Compton. The Australasian Theory Symposium, Jan 2005.
\end{itemize}


The next phase of the project addressed TCP and the Sockets API
(including also UDP and aspects of ICMP), producing a
protocol-level specification.  The main specification is given in the
following technical reports:
\begin{itemize}
    \item TCP, UDP, and Sockets: rigorous and experimentally-validated
      behavioural specification. Volume 1: Overview. Steve Bishop,
      Matthew Fairbairn, Michael Norrish, Peter Sewell, Michael Smith,
      Keith Wansbrough. 88pp. Technical Report 624. March 2005.

    \item TCP, UDP, and Sockets: rigorous and experimentally-validated
      behavioural specification. Volume 2: The Specification. Steve
      Bishop, Matthew Fairbairn, Michael Norrish, Peter Sewell,
      Michael Smith, Keith Wansbrough. 386pp. Technical Report
      625. March 2005.
\end{itemize}

These were accompanied by papers giving a systems-oriented
introduction to the work and a theory-oriented description of the specification idioms and symbolic model-checking technology used:
\begin{itemize}
    \item Rigorous specification and conformance testing techniques for network protocols, as applied to TCP, UDP, and Sockets. Steve Bishop, Matthew Fairbairn, Michael Norrish, Peter Sewell, Michael Smith, Keith Wansbrough. 12pp. In SIGCOMM 2005.
    \item Engineering with Logic: HOL Specification and Symbolic-Evaluation Testing for TCP Implementations. Steve Bishop, Matthew Fairbairn, Michael Norrish, Peter Sewell, Michael Smith, Keith Wansbrough. 14pp. In POPL 2006.
\end{itemize}


We then used similar techniques, but at design-time instead of after
the fact, for specification and validation work on a MAC protocol for
the SWIFT experimental optically switched network:
\begin{itemize}
\item Rigorous Protocol Design in Practice: An Optical
      Packet-Switch MAC in HOL. Adam Biltcliffe, Michael Dales, Sam
      Jansen, Tom Ridge, Peter Sewell.  In ICNP 2006.
\item SWIFT MAC Protocol: HOL Specification.
\end{itemize}


Returning to verification above network specifications, we
demonstrated that an operational semantics network model (abstracting
from our detailed service-level specification) could be integrated with a programming language semantics, and used for functional correctness verification of a fault-tolerant persistent distributed message queue algorithm:
\begin{itemize}
\item Verifying distributed systems: the operational approach. Tom Ridge.
In POPL 2009.
\end{itemize}



Finally, we have the specification of this technical report,  a
high-level service specification related to the earlier protocol-level
specification by a validated abstraction function.  This introduction
is an extended version of the paper:
\begin{itemize}
    \item A rigorous approach to networking: TCP, from
      implementation to protocol to service. Tom Ridge, Michael
      Norrish, Peter Sewell. In FM'08.
\end{itemize}


% See also the accompanying draft specification (and in pdf).
%
% A full description of the project, and the specification itself (typeset and extensively annotated):
%
%     \item NEW: TCP, UDP, and Sockets: Volume 3: The Service-level Specification. Steve Bishop, Matthew Fairbairn, Michael Norrish, Thomas Ridge, Peter Sewell, Michael Smith, Keith Wansbrough. Also in pdf. Draft.
%
%     \item Errata for the spec.
%
% A tarball of the HOL source files of the specification:
%
%     \item tarball-spec-public.tar.gz
%
% A short FAQ-style introduction:
%
%     \item The TCP Specification: A Quick Introduction. 5pp. February 2005. Steve Bishop, Matthew Fairbairn, Michael Norrish, Peter Sewell, Michael Smith, Keith Wansbrough. Also in pdf.
%
% A poster with a version of the `TCP state diagram' extracted from the specification. This is rather more complete than the usual diagram, but is still a very abstract and simplified view of the specification state space. It is intended to be printed at A1 size or bigger:
%
%     \item An approximation to the real TCP state diagram. Also in pdf.
%
% NEW: Peng Li used the specification as the basis for a purely functional Haskell implementation of a TCP stack for a web server. Here is
%
%     \item his implementation.
%
% A note written to aid the development of the TCP specification, describing some of the behaviour of the Linux implementation:
%
%     \item Flow Control in the Linux Network Stack. Note. Michael Smith, Steve Bishop. Also in pdf.
%
% The published versions of the TACS 2001 and ESOP 2002 papers appeared
% in LNCS and are (c) Springer-Verlag.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

% FIXME TCP is a complex protocol, and exhaustive validation requires significant resources.
%

\vspace*{-4mm}


\myheading{Summary} We presented a formal, mechanized, service-level
specification of TCP, tackling the full detail of the real-world
protocol. The specification is appropriate for formal and informal
reasoning about applications built above the Sockets layer, and about
the service that TCP and TCP-like protocols provide to the Sockets
layer. The service-level specification stands as a precise statement
of end-to-end correctness for TCP.
%
We also presented a formal abstraction function from our previous
protocol-level model of TCP to the service-level specification,
thereby explaining how stream-like behaviour arises from the protocol level.
%
We used novel validation tools, coupled with the results of previous
work, to validate both the service specification and the abstraction
function.
%
The specification, abstraction function, and testing infrastructure
were developed entirely in HOL.

%The abstraction function was also instrumental in validating the service-level specification.

\myheading{On the practice of protocol design}
This service-level specification is the latest in a line of work
developing rigorous techniques for real-world
protocol modelling and specification \cite{SSW01a,WNSS01:brief,NSW02,TCP:paper,TCP:POPLpaper,BDJRS06}.
In most of this work to date we have focused on post-hoc
specification of existing infrastructure
(TCP, UDP, ICMP, and the Sockets API) rather than new protocol design,
though the latter is our main goal.
%
This is for two reasons.
%
Firstly,
the existing infrastructure is ubiquitous, and likely to remain so for the foreseeable
future: these wire protocols and the Sockets API are stable
articulation points around which other software shifts.  It is
therefore well worth characterising exactly what they are, for the
benefit of both users and implementers.
%
Secondly, and more importantly, they are excellent test cases.  There
has been a great deal of theoretical work on idealised protocols, but,
to develop rigorous techniques
that can usefully be applied, they must be tested with realistic
protocols.   If we can deal with TCP and Sockets, with all their
accumulated legacy of corner cases and behavioural quirks, then our
techniques should certainly be applicable to new protocols.
%
We believe that that is now demonstrated, and it is confirmed by our
experience with design-time formalisation and conformance testing for
an experimental MAC protocol for an optically switched network
\cite{BDJRS06}.

In recent years there has been considerable interest in `clean slate'
networking design, and in initiatives such as FIND and GENI.
Protocols developed in such work should, we argue, be developed as
trios of running implementation, rigorous specification, and
verified conformance tester between the two.
Modest attention paid to this at design time would greatly
ease the task --- for example, specifying appropriate debug trace
information, and carefully identifying the deterministic parts of a
protocol specification, would remove the need for backtracking search during validation.
%
Declarative specification of the intended protocol behaviour,
free from the imperative control-flow imposed by typical
implementation languages, enables one to see unnecessary behavioural
complexities clearly.  Verified conformance testing makes it possible
to keep implementations and specifications in sync as they are
developed.
%
Together, they should lead to cleaner, better-understood and more
robust protocols, and hence to less costly and more robust infrastructure.


More specifically to TCP, we see two main directions for future
work.
%
One is simply to scale up our validation process, covering a wide
variety of common protocol stacks, increasing confidence still further
by testing against more traces, identifying and testing additional
invariants of connection states, and so forth, and producing a
packaged conformance tester for TCP implementations.
This would be useful, and on an industrial scale would be a relatively
small project (compared, perhaps, to the QA effort involved in
developing a new protocol stack), but doing this for an existing
protocol may be inappropriate for a small research group.
The weight of legacy complexity here is very large, so non-trivial
resources (perhaps several  man-years) would be needed to cope with the
detail, but the basic scientific questions, of \emph{how} to do this,
have now been solved.
%
Doing this for \emph{new} protocols, on the other hand,
seems clearly worthwhile, even with very limited resources.

The second, more research-oriented, question, is to consider not just
validation of end-to-end functional correctness (as we have done
here), but properties such as end-to-end performance. Ultimately one
could envisage proving network-wide properties, such as network
stability, thereby connecting highly
abstract properties of these protocols to the low-level details of their
implementations.

%.  For example, for future transport protocols
%one can envisage precisely relating a protocol-level specification
%to network models equipped with stability theorems.




\myheading{Acknowledgements} We gratefully acknowledge the use of the Condor facility in
the Computer Laboratory, work of Adam Biltcliffe on testing
infrastructure, and
 support from
a Royal Society University Research
Fellowship (Sewell)
and EPSRC grants EPC510712 and GRT11715. NICTA is funded by the Australian Government's Backing Australia's Ability initiative, in part through the Australian Research Council.


%%2009-02-18%\bibliographystyle{alpha}
%%2009-02-18\bibliographystyle{abbrv}
%%2009-02-18\bibliography{tr}
%%2009-02-18
%%2009-02-18\end{document}
%%2009-02-18
%%2009-02-18%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18\section{junk}
%%2009-02-18
%%2009-02-18mistake not to track packet-level invariants
%%2009-02-18
%%2009-02-18too non-deterministic? (unlikely timeliness properties are preserved)
%%2009-02-18
%%2009-02-18
%%2009-02-18%softerror is only
%%2009-02-18%used for ICMP part of the spec, and the keepalive timer is there
%%2009-02-18%presumably because we want to accurately model stream closure from
%%2009-02-18%keepalive timer not being reset. Indeed, this is the only function of
%%2009-02-18%di3\_topstuff in spec3.
%%2009-02-18
%%2009-02-18
%%2009-02-18FIXME talk about relative difficult in validation, regression testing etc.
%%2009-02-18Compared to the packet-level debugging phase, the service-level was
%%2009-02-18very pleasant. Packet-level validation rejected traces without much
%%2009-02-18indication of where the problem lay. However, because we were able to
%%2009-02-18check the service-level traces without backtracking, we were always
%%2009-02-18able to locate precisely which transition had caused the trace to fail
%%2009-02-18to check. Moreover, the traces were fully ground, so it was easy to
%%2009-02-18compare the transition to the rule and determine why the transition
%%2009-02-18failed to check. Since we knew that the packet-level transition was
%%2009-02-18valid according to the packet-level specification, the error could
%%2009-02-18only arise from a mistake in the service-level specification, or the
%%2009-02-18abstraction function, and it was often clear which was responsible. A
%%2009-02-18side-effect of fully ground traces was that a single transition
%%2009-02-18failing to check did not impact checking of later transitions, since
%%2009-02-18the transitions were independent. Thus, correcting an error in the
%%2009-02-18service-level specification for a particular rule only required
%%2009-02-18rechecking those transitions for which the rule applied. Moreover the
%%2009-02-18packet-level validation was independent of the abstraction function
%%2009-02-18and the service-level validation, so that once a set of traces had
%%2009-02-18validated at the packet-level, the subsequent stages did not need to
%%2009-02-18rerun packet-level validation. FIXME awful
%%2009-02-18%
%%2009-02-18The process is easier because all information about host transitions
%%2009-02-18is known. This contrasts strongly with the experience of debugging the
%%2009-02-18packet-level specification, and reinforces the conclusion from \cite{FIXMEsigcomm} that
%%2009-02-18complete debugging information about the state of the protocol over
%%2009-02-18time makes validation significantly simpler.
%%2009-02-18
%%2009-02-18Another feature of the service-level validation is that regression
%%2009-02-18testing can be carried out on later stages without affecting the
%%2009-02-18results of earlier stages. We already mentioned that we were committed
%%2009-02-18to validate the traces at the packet-level, prior to service-level
%%2009-02-18validation. However, once these traces had been validated, we never
%%2009-02-18had to re-run the packet-level validation. Applying the abstraction
%%2009-02-18function to the ground packet-level traces generated service-level
%%2009-02-18traces. This stage was only repeated when errors in the (relatively
%%2009-02-18compact) abstraction function were discovered. At the service-level,
%%2009-02-18invidividual trace transitions are independent of each other, and can
%%2009-02-18be checked in parallel. service-level transitions that failed to
%%2009-02-18validate against the specification were often caused by errors in the
%%2009-02-18correpsonding rules. Once the rule was corrected, we only needed to
%%2009-02-18re-validate transitions which corresponded to the corrected rule.
%%2009-02-18%
%%2009-02-18Although each stage is computationally expensive, the independence
%%2009-02-18between stages proved a boon to service-level validation.
%%2009-02-18
%%2009-02-18FIXME say want to share as much as possible between specifications- a
%%2009-02-18lot of work was reorg the specs; future work to abstract out the
%%2009-02-18common Sockets part of the specifications, to give more confidence
%%2009-02-18that the behaviour is shared and to modularise the specs.
%%2009-02-18
%%2009-02-18
%%2009-02-18------------------
%%2009-02-18
%%2009-02-18A network protocol, such as TCP, can be viewed at two levels: the
%%2009-02-18internal behaviour, in terms of packets on the wire, control blocks,
%%2009-02-18congestion control, etc., and the external user's view, concerned
%%2009-02-18with the end-to-end \emph{service} that the protocol provides to
%%2009-02-18applications.  Both are usually described in informal prose RFCs,
%%2009-02-18which are inevitably ambiguous.
%%2009-02-18
%%2009-02-18In previous work [SIGCOMM'05, POPL'06]
%%2009-02-18% don't write the cites like that in the actual paper, only in the
%%2009-02-18% web-form abstract!
%%2009-02-18we developed a formal internal-view
%%2009-02-18specification of TCP, in terms of individual TCP segments on the wire
%%2009-02-18and Sockets API interactions. This was written in higher-order logic,
%%2009-02-18mechanized using the HOL theorem prover, and validated against
%%2009-02-18real-world network traces.
%%2009-02-18
%%2009-02-18In this paper we develop a companion external-view specification,
%%2009-02-18essentially in terms of byte streams between socket endpoints.
%%2009-02-18It models just the \emph{user-visible} behaviour at
%%2009-02-18the Sockets API, abstracting from all non-observable details of the
%%2009-02-18implementation of TCP.
%%2009-02-18This makes it possible, for the first time, to precisely state what it
%%2009-02-18means for TCP to be `correct'.
%%2009-02-18%
%%2009-02-18Further, we define a precise abstraction relation between the two models,
%%2009-02-18and validate it (and the external-view specification itself) against
%%2009-02-18representative real-world traces.
%%2009-02-18%
%%2009-02-18The external-view specification can also be used for (informal and formal)
%%2009-02-18reasoning about applications above the Sockets API.
%%2009-02-18
%%2009-02-18We thereby show how
%%2009-02-18
%%2009-02-18
%%2009-02-18-------------------
%%2009-02-18
%%2009-02-18Key properties of TCP, such as end-to-end
%%2009-02-18correctness, are explicitly captured by the specification. The
%%2009-02-18specification is intended as a foundation for formal and informal
%%2009-02-18reasoning about applications written above TCP. At the same time, the
%%2009-02-18specification is a statement of the service TCP and TCP-like protocols
%%2009-02-18provide to the Sockets layer.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18------------------
%%2009-02-18
%%2009-02-18
%%2009-02-18We present a formal specification of TCP in terms of reliable
%%2009-02-18byte streams. The specification is written in higher-order logic,
%%2009-02-18mechanized using the HOL theorem prover, and validated against
%%2009-02-18real-world network traces.
%%2009-02-18
%%2009-02-18Implementors view TCP in terms of packets, control blocks, congestion
%%2009-02-18control, retransmission and so on. In contrast, application
%%2009-02-18programmers view TCP connections as reliable byte streams between
%%2009-02-18Sockets endpoints. These different views of TCP are not in
%%2009-02-18conflict. The packet-level implementation provides the service-level
%%2009-02-18service.
%%2009-02-18
%%2009-02-18The packet-level is described in RFCs, and implemented in several
%%2009-02-18networking stacks. However, RFCs are often vague and ambiguous, and
%%2009-02-18implementations differ in substantial ways. To address these problems,
%%2009-02-18in previous work we described a formal specification of TCP at the
%%2009-02-18packet-level.
%%2009-02-18
%%2009-02-18In this work, we develop a specification of TCP in terms of reliable
%%2009-02-18byte streams between Sockets endpoints. The specification is both
%%2009-02-18accurate, modelling all interesting behaviour at the Sockets
%%2009-02-18interface, and abstract, omitting all details of the packet-level
%%2009-02-18implementation of TCP. Key properties of TCP, such as end-to-end
%%2009-02-18correctness, are explicitly captured by the specification. The
%%2009-02-18specification is intended as a foundation for formal and informal
%%2009-02-18reasoning about applications written above TCP. At the same time, the
%%2009-02-18specification is a statement of the service TCP and TCP-like protocols
%%2009-02-18provide to the Sockets layer.
%%2009-02-18
%%2009-02-18
%%2009-02-18%%
%%2009-02-18%Both RFCs and implementations are concerned with low-level
%%2009-02-18%implementation details, whilst high-level properties, such as
%%2009-02-18%end-to-end correctness, are not adequately addressed.
%%2009-02-18
%%2009-02-18
%%2009-02-18%Formal reasoning about distributed algorithms is hard. The algorithms
%%2009-02-18%are usually implemented on top of a protocol stack, which is almost
%%2009-02-18%never formally specified. Ideally each layer of the stack, upto and
%%2009-02-18%including the algorithm, should be formally specified and
%%2009-02-18%verified. However, even specifying these layers is a difficult
%%2009-02-18%task. In this work, we develop a specification of TCP at the
%%2009-02-18%service-level. The specification is both accurate, preserving all
%%2009-02-18%interesting behaviour at the Sockets API interface, and abstract,
%%2009-02-18%omitting all details of the packet-level implementation of TCP. Key
%%2009-02-18%properties of TCP, such as end-to-end correctness, are explicitly
%%2009-02-18%captured by the specification. The specification is intended as a
%%2009-02-18%foundation for formal reasoning about algorithms written above TCP. At
%%2009-02-18%the same time, the specification can be read as a statement of the
%%2009-02-18%end-to-end correctness property of the packet-level implementation of TCP.
%%2009-02-18
%%2009-02-18
%%2009-02-18Important Dates
%%2009-02-18Paper Abstract/Title/Topic Registration: Jun 25, 2007,11:59PM PDT
%%2009-02-18Full paper due Monday, July 2, 2007, 11:59PM PDT
%%2009-02-18Notification of acceptance Monday, November 12, 2007
%%2009-02-18Final version due Tuesday, January 15, 2008
%%2009-02-18
%%2009-02-18FIXME morsels for INFOCOM
%%2009-02-18FIXME no record boundaries
%%2009-02-18FIXME abstraction ignores messages on the wire
%%2009-02-18
%%2009-02-18FIXME sockets gives the language, but what is missing is the queue between, and properties
%%2009-02-18
%%2009-02-18
%%2009-02-18\scalebox{0.95}{
%%2009-02-18\begin{minipage}{\columnwidth}
%%2009-02-18\showrule{\sendTIII}%
%%2009-02-18\end{minipage}
%%2009-02-18}
%%2009-02-18
%%2009-02-18
%%2009-02-18\begin{scriptsize}
%%2009-02-18\defnread
%%2009-02-18\end{scriptsize}
%%2009-02-18
%%2009-02-18This time, the final output stream is unaffected, [[out' = out]].  The
%%2009-02-18[[flgs]] processing is essentially the same as that for [[write]] and is
%%2009-02-18elided for clarity. The data processing is complicated by
%%2009-02-18[[peek]]. The initial [[in_.data]] is decomposed into the bytes that
%%2009-02-18are read, [[data]], and the bytes that remain in the stream after a
%%2009-02-18non-peeking read, [[post]]. The final [[in'.data]] is the same as
%%2009-02-18[[in_.data]] for a peeking read, otherwise, [[data]] is removed from
%%2009-02-18the front of the stream, leaving [[post]] remaining.
%%2009-02-18
%%2009-02-18
%%2009-02-18\myheading{Benefits of our approach} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18%
%%2009-02-18Our approach to service-level validation is one of several
%%2009-02-18alternatives. For example, the service-level could be validated
%%2009-02-18directly against real-world traces, without reference to the
%%2009-02-18protocol-level, or the abstraction function. However, our approach has
%%2009-02-18several advantages.
%%2009-02-18
%%2009-02-18\begin{itemize}
%%2009-02-18\item %
%%2009-02-18Validation consists of determining a service-level trace, and checking
%%2009-02-18that it is valid according to the specification. With alternative
%%2009-02-18approaches, these two tasks are typically intertwined, as they are at
%%2009-02-18the protocol-level. Our approach uses the abstraction function to
%%2009-02-18provide the service-level trace ``for free''.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18The ground service-level trace simplified the task of the
%%2009-02-18checker. Unobserved values are already determined, as are unobserved
%%2009-02-18transitions. Features of the protocol-level trace checker, such as
%%2009-02-18backtracking and constraint solving, are not required at the
%%2009-02-18service-level. The checker has only to validate each ground transition
%%2009-02-18independently.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18Regression testing was much faster for the service-level because the
%%2009-02-18validation stages are independent. For example, once a valid ground
%%2009-02-18protocol-level trace has been produced, it does not have to be
%%2009-02-18reproduced. Similarly, mapping the abstraction function over the
%%2009-02-18ground protocol-level trace produces a ground service-level trace, and
%%2009-02-18provided the abstraction function does not changes, this also does not
%%2009-02-18have to be reproduced. Finally, each service-level transition is
%%2009-02-18independent, and once a transition has been checked, it does not have
%%2009-02-18to be rechecked, unless the corresponding service-level rule changes.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18The service-level trace checker indicates failing transitions
%%2009-02-18precisely, because the service-level trace is already
%%2009-02-18determined. Alternative approaches which combine trace determination
%%2009-02-18and trace checking, as with the protocol-level, can only report that a
%%2009-02-18trace failed to check, without indicating precisely which transitions
%%2009-02-18are problematic.
%%2009-02-18
%%2009-02-18\end{itemize}
%%2009-02-18
%%2009-02-18
%%2009-02-18Another measure of the complexity of the specifications is how long
%%2009-02-18each took to produce. Of course, we had access to the protocol-level
%%2009-02-18when writing the service-level. Nevertheless, the majority of the
%%2009-02-18service-level was written in a four month period, by one person. The
%%2009-02-18majority of the effort to produce the service-level specification lay
%%2009-02-18in validation. Still, the total time required was approximately 2
%%2009-02-18person years, which compares favourably with the 9 years devoted to
%%2009-02-18the protocol-level specification.
%%2009-02-18
%%2009-02-18
%%2009-02-18%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18\section{Comparing protocol and service} \label{sect:comparison}
%%2009-02-18
%%2009-02-18%stream-spec: sockets and streams packet-level: sockets and packet
%%2009-02-18%processing
%%2009-02-18
%%2009-02-18%the packet processing is the part of the spec that is very complicated. sockets are similar between specifications
%%2009-02-18
%%2009-02-18In this section, we compare the two specifications to assess to what
%%2009-02-18extent the service-level abstracts from the detail of the protocol-level:
%%2009-02-18the service-level is intended as a foundation for formal reasoning
%%2009-02-18about algorithms written above the Sockets interface, so it is
%%2009-02-18important that it is conceptually simple.
%%2009-02-18
%%2009-02-18FIXME In one respect, the service-level and protocol-level are
%%2009-02-18incomparable, because the service-level explicitly captures the notion
%%2009-02-18of byte stream, which is vital for reasoning about code which uses the
%%2009-02-18Sockets interface to TCP.
%%2009-02-18
%%2009-02-18
%%2009-02-18%
%%2009-02-18However, to ensure the complex behaviour of the Sockets interface is captured
%%2009-02-18at the service-level, the Sockets rules are essentially shared with
%%2009-02-18the protocol-level. The abstraction and conceptual simplicity of the
%%2009-02-18service-level is really evident in the non-Socket rules that deal
%%2009-02-18with maintaining the end-to-end connection. These rules, which are the
%%2009-02-18most complicated part of the protocol-level, are trivial at the
%%2009-02-18service-level.
%%2009-02-18
%%2009-02-18%
%%2009-02-18For example, a key rule is [[deliver_in_3]], which describes the
%%2009-02-18passage of a segment from the host input queue to the relevant socket
%%2009-02-18receive queue. Table \ref{table:diIII} shows the line counts for the
%%2009-02-18definition of [[deliver_in_3]] and related auxiliary functions.
%%2009-02-18
%%2009-02-18\begin{table}[h]
%%2009-02-18\begin{center}
%%2009-02-18\begin{tabular}{|l|r|r|}
%%2009-02-18\hline
%%2009-02-18Definition		& Protocol-level	& service-level \\
%%2009-02-18\hline
%%2009-02-18di3\_topstuff		& 88	& 21 \\
%%2009-02-18di3\_newackstuff	& 203	& 64 \\
%%2009-02-18di3\_ackstuff		& 118	& 66 \\
%%2009-02-18di3\_datastuffreally 	& 246 	& - \\
%%2009-02-18di3\_datastuff		& 80	& 10 \\
%%2009-02-18di3\_ststuff		& 179	& 161 \\
%%2009-02-18di3\_socks\_update 	& 75	& 67 \\
%%2009-02-18deliver\_in\_3		& 163	& 133 \\
%%2009-02-18\hline
%%2009-02-18Total 			& 1152	& 522 \\
%%2009-02-18\hline
%%2009-02-18\end{tabular}
%%2009-02-18\end{center}
%%2009-02-18\caption{deliver\_in\_3 and auxiliaries, line counts per definition} \label{table:diIII}
%%2009-02-18\end{table}
%%2009-02-18
%%2009-02-18[[di3_ststuff]] deals with state transitions for the socket, and the
%%2009-02-18code is almost identical between specifications.
%%2009-02-18% this sentence no verb
%%2009-02-18Similarly for [[di3_socks_update]].
%%2009-02-18%
%%2009-02-18Apart from these two rules, the definitions are significantly reduced,
%%2009-02-18and the overall line count for the service-level specification is
%%2009-02-18roughly half that of the protocol-level.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18\newpage
%%2009-02-18\section{OLD CONCLUSION}
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18----------------------------------------
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18We emphasize that our general
%%2009-02-18methodology is applicable to all network protocols, not just TCP, and
%%2009-02-18at all stages of protocol development, not just post-hoc. For example,
%%2009-02-18we successfully applied it to an optical networking protocol at design
%%2009-02-18time \cite{BDJRS06}.
%%2009-02-18
%%2009-02-18\myheading{Proposals} A number of proposals issue from this work.
%%2009-02-18
%%2009-02-18\begin{itemize}
%%2009-02-18\item %
%%2009-02-18Writing specifications takes much less time than validating
%%2009-02-18them. Research should be directed at reducing the validation effort.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18Validation at the protocol-level and service-level is computationally
%%2009-02-18expensive. On demand access to large compute resources would greatly
%%2009-02-18reduce the time spent on validation. These resources should be made
%%2009-02-18available to researchers.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18The difficulty of validation arises from determining unobserved host
%%2009-02-18state, and unobserved transitions. Protocol implementations should
%%2009-02-18provide complete debugging information about protocol state and
%%2009-02-18transitions, which would make validation significantly simpler.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18A large part of the validation effort was expended setting up and
%%2009-02-18configuring test networks, developing instrumentation, configuring
%%2009-02-18hosts to have accurate timing information, and so on. Initial
%%2009-02-18validation could employ virtualization for trace generation and to
%%2009-02-18provide debugging information. This would avoid many problems which
%%2009-02-18afflict real-world network trace capture.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18Although a specification is often not executable, a specification
%%2009-02-18where ground transitions are recursively (or better, primitive
%%2009-02-18recursively) checkable is well suited to validation. Ideally there
%%2009-02-18should be an easy way to derive a ground transition checker from the
%%2009-02-18specification.
%%2009-02-18
%%2009-02-18\item %
%%2009-02-18A general method to derive an implementation from a specification
%%2009-02-18would allow rapid prototyping of protocols. Typically this would
%%2009-02-18require constraints on the way the specification is written, without
%%2009-02-18requiring the specification itself to be directly executable.
%%2009-02-18
%%2009-02-18\end{itemize}
%%2009-02-18
%%2009-02-18\myheading{Future work}
%%2009-02-18%
%%2009-02-18There are many possibilities for future work, some of which we touched
%%2009-02-18on in the proposals.
%%2009-02-18%
%%2009-02-18One of the aims of the specification is to provide a foundation for
%%2009-02-18formal reasoning about algorithms that use TCP and the Sockets API. We
%%2009-02-18are interested in extending the work in this direction.
%%2009-02-18%
%%2009-02-18We also hope to apply our approach to more protocols, both at design time,
%%2009-02-18and post-hoc. Protocols which are critical to the functioning of the
%%2009-02-18Internet, such as DNS, are good targets.
%%2009-02-18%
%%2009-02-18We would like to work on reducing the validation effort in general,
%%2009-02-18perhaps deriving a ground transition checker from a specification. We
%%2009-02-18would also like to investigate deriving implementations from a
%%2009-02-18specification, which would facilitate rapid prototyping.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18-------------------editing 2007-11-07
%%2009-02-18For TCP, the protocol involves TCP segments on the wire, control blocks,
%%2009-02-18congestion control, etc., whereas the service it provides,
%%2009-02-18%
%%2009-02-18via the Socket API \texttt{connect}, \texttt{listen}, etc.,
%%2009-02-18%
%%2009-02-18is most clearly
%%2009-02-18expressed in terms of duplex byte streams.
%%2009-02-18
%%2009-02-18
%%2009-02-18It captures just the end-to-end \emph{user-visible} behaviour at
%%2009-02-18the Sockets API, abstracting from all non-observable details of the
%%2009-02-18TCP protocol.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18Network protocols can be viewed at three levels. There is the
%%2009-02-18high-level service they provide, the low-level protocol that
%%2009-02-18implements the service, and the realisation of the protocol in
%%2009-02-18endpoint implementation code. For TCP, for example, the protocol
%%2009-02-18involves TCP segments on the wire, control blocks, congestion control,
%%2009-02-18etc., whereas the service it provides is that of duplex byte
%%2009-02-18streams.
%%2009-02-18
%%2009-02-18
%%2009-02-18Most of our work to date has focussed on post hoc specification of
%%2009-02-18TCP, as a ubiquitous and typical example that is worth detailed study
%%2009-02-18for its own sake, but our main goal is to make such techniques
%%2009-02-18available for new protocol design, to ease the task of building future
%%2009-02-18high-quality infrastructure.
%%2009-02-18
%%2009-02-18
%%2009-02-18This makes it possible, for the first time, to state precisely what
%%2009-02-18functional properties TCP
%%2009-02-18is supposed to achieve.
%%2009-02-18We develop further verified testing methods,
%%2009-02-18to relate it to both the implementation behaviour and  to the protocol
%%2009-02-18level.
%%2009-02-18%
%%2009-02-18
%%2009-02-18(and also to underspecify precisely, where that is appropriate)
%%2009-02-18
%%2009-02-18
%%2009-02-18\myheading{Service-level specification} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18%
%%2009-02-18We give a formal specification of the service provided by TCP and the
%%2009-02-18Sockets API.
%%2009-02-18%
%%2009-02-18%
%%2009-02-18%
%%2009-02-18It is written in higher-order logic,
%%2009-02-18mechanized using the HOL theorem prover.
%%2009-02-18%, and validated against
%%2009-02-18%real-world traces.
%%2009-02-18It is accurate, capturing all behaviour at the
%%2009-02-18Sockets interface, and abstract, omitting protocol details that are
%%2009-02-18unobservable at the service level, such as congestion control and
%%2009-02-18retransmission.
%%2009-02-18It is thus an \emph{end-to-end} specification, in a novel sense:
%%2009-02-18it captures the intended end-to-end byte stream behaviour of a
%%2009-02-18TCP connection
%%2009-02-18from one endpoint Sockets API to another, including
%%2009-02-18the details of opening and closing
%%2009-02-18connections visible via \texttt{bind}, \texttt{listen},
%%2009-02-18\texttt{connect}, etc.
%%2009-02-18
%%2009-02-18
%%2009-02-18%
%%2009-02-18The specification
%%2009-02-18%can be used as a basis for formal and informal
%%2009-02-18%reasoning about applications above the Sockets layer, and TCP and
%%2009-02-18%TCP-like protocol implementations below the Sockets layer. It
%%2009-02-18provides
%%2009-02-18application programmers with a conceptually simple statement of the
%%2009-02-18service provided by TCP and Sockets.
%%2009-02-18It also serves a methodological role as an
%%2009-02-18example of real-world rigorous  specification.
%%2009-02-18%
%%2009-02-18We say the protocol conforms to the service-level
%%2009-02-18specification iff it has the same behaviour at the Sockets interface.
%%2009-02-18
%%2009-02-18
%%2009-02-18\myheading{Relating protocol and service} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18%
%%2009-02-18We have formally stated the relationship, expressed as an abstraction
%%2009-02-18function, between our previous protocol-level model of TCP and the
%%2009-02-18service-level specification.  This abstraction function maps low-level
%%2009-02-18host states (including TCP control blocks etc.) and a low-level
%%2009-02-18network state (multisets of packets on the wire) to high-level host
%%2009-02-18states and logical stream objects for each connection.  It thereby
%%2009-02-18explains precisely how the protocol implements the service.  This in
%%2009-02-18turn strengthens the statement of correctness for TCP, and provides
%%2009-02-18extra assurance that the specification is accurate.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18%,
%%2009-02-18%that is to say, if it delivers bytes in order. Thus, the service level
%%2009-02-18%stands as a statement of correctness for the protocol level, and
%%2009-02-18%% "statement of correctness" = "specification"???
%%2009-02-18%implementations.
%%2009-02-18
%%2009-02-18
%%2009-02-18\myheading{Validation} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18%
%%2009-02-18To ensure the service-level specification accurately captures the behaviour of implementations, we developed trace generation
%%2009-02-18and capture infrastructure, and a purpose built symbolic model
%%2009-02-18checker above HOL, which we used to validate real-world network traces against
%%2009-02-18the specification.
%%2009-02-18%
%%2009-02-18The trace checker is extremely rigorous, automatically producing a machine checked
%%2009-02-18proof of admissibility for each successfully validated trace.
%%2009-02-18%
%%2009-02-18% We first validated the traces against our previous protocol model
%%2009-02-18% using our existing trace checker, then used the abstraction function
%%2009-02-18% to lift the results to the service level, where we validated
%%2009-02-18% against the service-level specification using the new trace checker.
%%2009-02-18% %
%%2009-02-18% Independent validation against both protocol model and service level
%%2009-02-18% specification provides additional assurance, since the protocol model
%%2009-02-18% has itself been extensively validated against real-world network
%%2009-02-18% traces. In addition, the use of the abstraction function significantly strengthens
%%2009-02-18% service-level validation.
%%2009-02-18% %
%%2009-02-18TCP is a complicated protocol, and exhaustive validation of the
%%2009-02-18service level would require significant resources. We restrict
%%2009-02-18ourselves to validating a small number (\nnn) of representative network traces, each exhibiting different
%%2009-02-18end-to-end behaviour. All of these validate successfully, giving
%%2009-02-18confidence that scaling
%%2009-02-18up the process would be essentially routine.
%%2009-02-18
%%2009-02-18
%%2009-02-18%Furthermore,
%%2009-02-18%there are good reasons, quite separate from validation, to believe
%%2009-02-18%that the specification is relatively free of errors, see
%%2009-02-18%Sect. \ref{sect:validation}.
%%2009-02-18
%%2009-02-18%\end{itemize}
%%2009-02-18
%%2009-02-18A formal mathematical document, written using logic and mechanized in
%%2009-02-18a theorem prover, is the most precise way to specify protocols
%%2009-02-18currently known. The initial effort is more than would be the case with
%%2009-02-18traditional approaches, but far from prohibitive: the specification
%%2009-02-18and validation described here represents just over 2 person years of
%%2009-02-18work.
%%2009-02-18Moreover, our experience shows that doing similar work at design-time,
%%2009-02-18rather than reverse-engineering precise specifications for existing protocols,
%%2009-02-18requires substantially less effort \cite{BDJRS06}.
%%2009-02-18 We believe the advantages, of increased clarity, and the possibility of deriving
%%2009-02-18conformance checkers directly from the formal specification, far
%%2009-02-18outweigh the extra effort involved.
%%2009-02-18
%%2009-02-18
%%2009-02-18Our specification is written in higher-order logic using the HOL theorem prover \cite{Gordon93,hol}.
%%2009-02-18%
%%2009-02-18The main HOL syntax used is as follows.
%%2009-02-18%
%%2009-02-18Higher-order logic is expressive, clear, and
%%2009-02-18completely precise.
%%2009-02-18%
%%2009-02-18Whilst it may be unfamiliar at first sight, our experience (both for
%%2009-02-18TCP and optical networking~\cite{BDJRS06}) is that systems researchers
%%2009-02-18can become fluent relatively quickly.
%%2009-02-18
%%2009-02-18
%%2009-02-18%
%%2009-02-18Each rule has a name, \eg
%%2009-02-18       [[bind_5]], [[deliver_in_1]] \etc, and various attributes.
%%2009-02-18       These rules form the main part of the specification.
%%2009-02-18% in Volume 2,
%%2009-02-18%       from \S\specSocketCalls{} onwards.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18For example, the service-level TCP control
%%2009-02-18block contains 2 fields, compared to 44 for the protocol level.
%%2009-02-18
%%2009-02-18
%%2009-02-18This can be seen by examining the model of the hosts in each
%%2009-02-18specification. Hosts are represented as records, with input and output queue fields, routing tables,
%%2009-02-18file and socket maps, and so on. The socket map maps socket ids to
%%2009-02-18sockets, which are themselves records containing further fields. As
%%2009-02-18the data becomes more specific to TCP, the specifications diverge.
%%2009-02-18%
%%2009-02-18For example, the protocol-level TCP control block contains many fields,
%%2009-02-18including retransmit and keep alive timers; window sizes, sequence
%%2009-02-18position and scaling information; timestamping and round trip
%%2009-02-18times. These are not relevant to the service level, and so do not
%%2009-02-18appear in the service-level TCP control block.
%%2009-02-18%
%%2009-02-18Below we show, for each specification, the
%%2009-02-18number of fields for each record used in the model of the host. It is
%%2009-02-18clear that the service-level model of the host state is considerably
%%2009-02-18simpler than that at the protocol level.
%%2009-02-18
%%2009-02-18%\begin{table}[h]
%%2009-02-18{\small
%%2009-02-18\begin{center}
%%2009-02-18\begin{tabular}{|l|r|r|}
%%2009-02-18\hline
%%2009-02-18%                & \multicolumn{2}{c}{fields} \\
%%2009-02-18Host record type	&{Protocol-level}	&service-level \\
%%2009-02-18\hline
%%2009-02-18tcpReassSegment &4              & - \\
%%2009-02-18rexmtmode       &3              & - \\
%%2009-02-18rttinf          &8              & - \\
%%2009-02-18tcpcb           &44             & 2 \\
%%2009-02-18tcp\_socket      &8              & 3 \\
%%2009-02-18socket          &9              & 9 \\
%%2009-02-18host            &14             & 14 \\
%%2009-02-18\hline
%%2009-02-18Total		&90		& 28 \\
%%2009-02-18\hline
%%2009-02-18\end{tabular}
%%2009-02-18% FIXME tcp\_socket currently 5 with sndq rcvq
%%2009-02-18\end{center}}
%%2009-02-18%\caption{Host record types, fields per record} \label{table:hostRecordTypes}
%%2009-02-18%\end{table}
%%2009-02-18
%%2009-02-18
%%2009-02-18%The key property of the abstraction function is that every valid trace
%%2009-02-18%at the protocol-level maps to a valid trace at the service-level. Ideally
%%2009-02-18%this property should be formally proved, but (we believe) this is
%%2009-02-18%currently beyond the state of the art. An alternative is to validate
%%2009-02-18%this property against real-world traces.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18For the protocol model we developed in previous work, one
%%2009-02-18possible way to ensure that the
%%2009-02-18
%%2009-02-18How can we ensure that TCP implementations (written in C), our
%%2009-02-18previous protocol-level model (in HOL), and our new service-level
%%2009-02-18specification (also in HOL) describe the same system?
%%2009-02-18%
%%2009-02-18
%%2009-02-18
%%2009-02-18We instrumented a test network and wrote tests to drive hosts on the
%%2009-02-18network to communicate with each other over TCP, recording the results
%%2009-02-18as real-world traces.
%%2009-02-18%
%%2009-02-18We then ensured that the specification admitted those traces by
%%2009-02-18running a special-purpose symbolic model checker in HOL, correcting
%%2009-02-18the specification when we discovered errors.
%%2009-02-18%
%%2009-02-18Because it is based directly on the formal specification, the checker
%%2009-02-18is extremely rigorous, producing a machine checked proof of
%%2009-02-18admissibility for each successfully validated trace, though obviously
%%2009-02-18no testing-based method can be complete.
%%2009-02-18
%%2009-02-18In this section we describe service-level validation, discuss its
%%2009-02-18relation to previous protocol-level validation, and illustrate the key
%%2009-02-18role played by the abstraction function.
%%2009-02-18
%%2009-02-18
%%2009-02-18%
%%2009-02-18\myheading{Real-world trace generation and capture} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18%
%%2009-02-18We wrote tests to exercise the end-to-end behaviour of TCP, generating
%%2009-02-18real-world traces of network behaviour, generalising our previous
%%2009-02-18single-ended test infrastructure.
%%2009-02-18
%%2009-02-18%. Traces consist of information
%%2009-02-18%that is observable on our instrumented test network, typically calls
%%2009-02-18%and returns at the Sockets interface, messages sent and received on
%%2009-02-18%the wire, and occasionally information about internal host state that
%%2009-02-18%is revealed by BSD kernel debug records. See Fig. \ref{fig:exampleTrace} for an excerpt.
%%2009-02-18%
%%2009-02-18%%\begin{figure}
%%2009-02-18%%\input{trace0963.tex}
%%2009-02-18%%\caption{Example trace} \label{fig:exampleTrace}
%%2009-02-18%%\end{figure}
%%2009-02-18%%
%%2009-02-18%Trace generation and trace capture required significant
%%2009-02-18%infrastructure. Previous protocol-level validation focused on
%%2009-02-18%exhaustively exercising the Sockets interface on a \emph{single host},
%%2009-02-18%and few of the tests explored the end-to-end behaviour of TCP. To
%%2009-02-18%improve trace coverage, we wrote additional tests, focusing on
%%2009-02-18%end-to-end transmission of data over a TCP connection.
%%2009-02-18%%For example, a
%%2009-02-18%%typical trace description reads: %
%%2009-02-18%%% trace0963
%%2009-02-18%%``establish a connection; send a
%%2009-02-18%%string on the test host; receive the string on the auxiliary host;
%%2009-02-18%%send a string on the auxiliary host; receive the string on the test
%%2009-02-18%%host''.
%%2009-02-18%We then enhanced the trace capture infrastructure, in order
%%2009-02-18%to record the behaviour of the
%%2009-02-18%\emph{network}, rather than just an individual host.
%%2009-02-18
%%2009-02-18%FIXME could prove that the Sockets API calls (at least) respect the abstraction
%%2009-02-18
%%2009-02-18
%%2009-02-18Fully ground protocol traces include full information about what
%%2009-02-18happened during the trace, which is extremely useful for service-level
%%2009-02-18validation. For this reason, we rewrote our previous protocol-level
%%2009-02-18trace checker to output a fully ground network trace on successful validation.
%%2009-02-18
%%2009-02-18%The checking task is extremely compute intensive, and in order to make
%%2009-02-18%it feasible, the work was distributed across a large number of
%%2009-02-18%machines. Still, the process of trace generation and validation takes
%%2009-02-18%several weeks, and regression testing is a lengthy process.
%%2009-02-18
%%2009-02-18%The checker is itself above HOL, and so its results are guaranteed
%%2009-02-18%correct (modulo only the possibility of errors in the small HOL
%%2009-02-18%kernel): checking each trace essentially involves an
%%2009-02-18%automatically-generated and machine-checked proof that the trace is
%%2009-02-18%accepted by the specification.
%%2009-02-18%%
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18\myheading{Service-level validation} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%2009-02-18%
%%2009-02-18For each real-world trace, service-level validation involves finding a
%%2009-02-18corresponding service-level trace that is admitted by the service-level
%%2009-02-18specification. In this, it exactly mirrors protocol-level
%%2009-02-18validation. However, the task is hugely simplified because of the
%%2009-02-18existence of the ground protocol-level network trace.
%%2009-02-18
%%2009-02-18%
%%2009-02-18%Although the protocol-level checker is used to produce ground
%%2009-02-18%service-level traces, and these then provide information about which
%%2009-02-18%rule to use at the service level, the service-level checker itself is
%%2009-02-18%independent of the protocol level.
%%2009-02-18
%%2009-02-18%Validating a service-level trace produced by applying the abstraction
%%2009-02-18%function to a packet-level trace gives greater assurance than
%%2009-02-18%validating the real-world trace directly, since we restrict the number
%%2009-02-18%of service-level traces that we consider to a single trace in the image
%%2009-02-18%of the abstraction function.
%%2009-02-18
%%2009-02-18%The key property of the abstraction function is that it maps valid
%%2009-02-18%packet-level traces to valid service-level traces. As noted previously,
%%2009-02-18%we have not proved this property, but instead we have validated it by
%%2009-02-18%testing. service-level validation is also validation of the abstraction
%%2009-02-18%function: if a trace failed to validate, the error was either in the
%%2009-02-18%service-level specification, or in the abstraction function.
%%2009-02-18
%%2009-02-18
%%2009-02-18In fact, traces are first
%%2009-02-18validated against the protocol model. This was for two reasons.
%%2009-02-18%
%%2009-02-18First, as we shall see, valid protocol-level traces provide important information to the
%%2009-02-18service-level trace checker.
%%2009-02-18%
%%2009-02-18Second, protocol-level validation speeds debugging, by ensuring that
%%2009-02-18failures of service-level validation are due to errors in the
%%2009-02-18service-level specification, or in the abstraction function, and not in
%%2009-02-18the protocol model.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18%
%%2009-02-18%The service-level trace
%%2009-02-18%has the same observable behaviour as the protocol-level trace, which in
%%2009-02-18%turn has the same behaviour as the real-world trace. The key property
%%2009-02-18%of the abstraction function implies that the service-level trace is
%%2009-02-18%valid according to the specification. This property has not been
%%2009-02-18%proved, so
%%2009-02-18%
%%2009-02-18
%%2009-02-18As at the protocol level, we wrote a special-purpose service-level
%%2009-02-18checker in HOL which performs symbolic evaluation of the specification
%%2009-02-18with respect to ground service-level traces. The checking process is
%%2009-02-18much simpler than that at the protocol level because all host values,
%%2009-02-18and all transitions, are already known. All that remains is to check
%%2009-02-18each ground service-level transition against the specification.
%%2009-02-18
%%2009-02-18
%%2009-02-18% new MN stuff (following may not be appropriate for INFOCOM audience)
%%2009-02-18The most significant difference between the old and new checkers is
%%2009-02-18that the former had to perform a depth-first search to even determine
%%2009-02-18which rule of the protocol model was appropriate.  Because
%%2009-02-18that work has already been done, and because the two specifications
%%2009-02-18have been constructed so that their individual rules correspond, the
%%2009-02-18service-level checker does not need to do this search.  Instead, it can
%%2009-02-18simply check the service-level version of the rule that was checked at
%%2009-02-18the protocol level.  In particular, this means that the service-level
%%2009-02-18checker need not attempt to infer the existence of unobservable
%%2009-02-18$\tau$-transitions.
%%2009-02-18
%%2009-02-18
%%2009-02-18If a trace has passed protocol-level validation, then a failure to
%%2009-02-18validate at the service level can only be because of errors in the
%%2009-02-18service-level specification, or in the abstraction function.
%%2009-02-18
%%2009-02-18
%%2009-02-18In previous work \cite{TCP:paper,TCP:POPLpaper}, we described a
%%2009-02-18low-level protocol model of TCP comprising roughly 30\,000 lines FIXME reason is complexity of
%%2009-02-18higher-order logic (with comments). We tied the model to the
%%2009-02-18implementations by verified testing FIXME major part of approach. In this paper, we discuss a
%%2009-02-18companion specification of the high-level service TCP provides.
%%2009-02-18%
%%2009-02-18
%%2009-02-18For example, at the protocol level, if host boolean flag
%%2009-02-18$b_1$ is set, the model may allow one transition $t_\top$, and if
%%2009-02-18unset, another $t_\bot$. If we omit the boolean in the service
%%2009-02-18specification, then we have to allow both transitions to occur.
%%2009-02-18
%%2009-02-18
%%2009-02-18However, we may know an
%%2009-02-18invariant, for example, that another boolean $b_2$, present also at
%%2009-02-18the service level, implies $b_1$. If $b_2$ is set, the service
%%2009-02-18specification can be more precise by only allowing transition
%%2009-02-18$t_\top$. Of course, in reality the invariants are considerably more
%%2009-02-18complex. Moreover, they are not recorded with the protocol model (or
%%2009-02-18the C implementation code), and must be constructed by hand. Thus, the
%%2009-02-18process of writing the service specification is complicated, and
%%2009-02-18involves using considerable knowledge of the protocol invariants to
%%2009-02-18abstract and simplify the protocol transitions as accurately as
%%2009-02-18possible, preserving behaviour at the Sockets API.
%%2009-02-18
%%2009-02-18In reality, TCP is much more
%%2009-02-18complex than a simple sliding window protocol, as evidenced by the
%%2009-02-18size of typical implementations, and our previous protocol model.
%%2009-02-18
%%2009-02-18Having decided on which parts of the protocol state we retain at the service level, and the general form of the specification, writing the specification
%%2009-02-18could be done almost mechanically, by existentially quantiying the
%%2009-02-18fields that are missing at the service level, for each service-level
%%2009-02-18transition.
%%2009-02-18
%%2009-02-18
%%2009-02-18\section{FOO}
%%2009-02-18
%%2009-02-18
%%2009-02-18memo: all this in hol - symbolic eval, grounding, mapping abs fn, etc
%%2009-02-18
%%2009-02-18---
%%2009-02-18
%%2009-02-18The complexity of protocol-level validation is mainly due to the
%%2009-02-18depth-first search and backtracking, and the constraint handling, both
%%2009-02-18of which are necessary because real-world observed traces do not
%%2009-02-18record complete information about the state of the hosts, or the
%%2009-02-18transitions that occur. The purpose of the search and constraint
%%2009-02-18handling is to determine this missing information and so determine
%%2009-02-18which transitions occurred. In essence, the test oracle receives a
%%2009-02-18symbolic trace, with uninstantiated variables representing the unknown
%%2009-02-18information, and after possibly inserting some unobservable
%%2009-02-18transitions, produces a ground trace, valid according to the protocol
%%2009-02-18model. We rewrote our previous protocol-level oracle extensively, in
%%2009-02-18order to produce these ground traces.
%%2009-02-18
%%2009-02-18For a given trace, protocol-level validation fully determines which
%%2009-02-18transitions occurred. We map the resulting fully ground trace, using
%%2009-02-18the abstraction function, into a fully ground service-level trace.
%%2009-02-18%
%%2009-02-18It is then necessary to check validity of this trace, which requires a
%%2009-02-18service-level test oracle. Crucially the process can be a lot simpler
%%2009-02-18because each transition can be checked in isolation, rather than
%%2009-02-18resorting to depth-first search and backtracking.
%%2009-02-18%
%%2009-02-18In this way, protocol-level validation, and the abstraction function,
%%2009-02-18are used to simplify the task of service-level validation.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18----------------------------
%%2009-02-18
%%2009-02-18FIXME Ideally one would prove formally that, given the invariants, the
%%2009-02-18protocol-level and service-level correspond. The problem here is to
%%2009-02-18identify the invariants themselves, and to prove that they are
%%2009-02-18preserved by the model. Again, the problem is one of
%%2009-02-18feasibility. However, we believe it would be feasible to prove this
%%2009-02-18for the relatively simple Sockets rules. One advantage would be that
%%2009-02-18validation would no longer have to check service-level Socket rule
%%2009-02-18transitions.
%%2009-02-18
%%2009-02-18
%%2009-02-18
%%2009-02-18%FIXME MN write something here?
%%2009-02-18%FIXME strengthened correctness statement
%%2009-02-18
%%2009-02-18The HOL specifications described in the previous sections are intended
%%2009-02-18to accurately capture the behaviour of a real-world system. Arguing
%%2009-02-18that a small specification corresponds to a simple real-world system
%%2009-02-18can be extremely challenging. Here, we are faced with very large
%%2009-02-18specifications and a very complex real-world system. We have developed
%%2009-02-18rigorous techniques for validating formal specifications against
%%2009-02-18real-world systems, and in this section we describe how we applied
%%2009-02-18these techniques to validate the service specification, and the role
%%2009-02-18played by the abstraction function.
%%2009-02-18
%%2009-02-18The correspondence between the service specification and the
%%2009-02-18real-world implementations relies on that between the protocol model
%%2009-02-18and the real-world implementations, which we briefly review here.
%%2009-02-18%
%%2009-02-18Ideally one would prove formally that the implementations and the
%%2009-02-18protocol model corresponded, using a formal C semantics to model the
%%2009-02-18implementation code. This would involve further demonstrating that the
%%2009-02-18C semantics corresponds to the behaviour of the real-world C programs.
%%2009-02-18%
%%2009-02-18Moreover, proving the relationship between the levels in this way
%%2009-02-18would be a very challenging task. One of the main barriers is the
%%2009-02-18scale of TCP implementations, including legacy behavioural intricacies
%%2009-02-18of TCP and Sockets, which were not designed with verification in mind.
%%2009-02-18%
%%2009-02-18An alternative, which we adopted to validate the protocol model, is to
%%2009-02-18establish confidence by testing the model against the real-world
%%2009-02-18system. This involves generating real-world traces of system
%%2009-02-18behaviour, and using a test oracle to check that the traces are valid
%%2009-02-18according to the model.
%%2009-02-18%
%%2009-02-18The test oracle is a special-purpose checker that performs symbolic
%%2009-02-18evaluation of the protocol model with respect to the real-world
%%2009-02-18traces.
%%2009-02-18%
%%2009-02-18This approach is pragmatic, cost-effective, and scales to large
%%2009-02-18systems. Moreover, the formal model is directly used as the basis of
%%2009-02-18the test oracle, which is constructed inside the HOL theorem prover
%%2009-02-18itself. This gives formal guarantees about the results of validation,
%%2009-02-18as we describe later. FIXME
%%2009-02-18
%%2009-02-18Validation is an iterative process, with failures indicating problems
%%2009-02-18in the protocol model, which are corrected before validation is
%%2009-02-18retried. Ideally each iteration should take a short time, to
%%2009-02-18facilitate regression testing when changes are made to the model.
%%2009-02-18%
%%2009-02-18Unfortunately, validation is a computationally intensive task,
%%2009-02-18the complexity arising from lack of information about the state of the
%%2009-02-18real-world observed hosts, lack of information about which transitions
%%2009-02-18occurred, and non-determinism in the specification. Not all the
%%2009-02-18information in the hosts can be observed when generating traces, and
%%2009-02-18not all host transitions are observable. Moreover, the specification
%%2009-02-18is highly non-deterministic, often with many transitions potentially
%%2009-02-18applicable to a given host.
%%2009-02-18%
%%2009-02-18The test oracle attempts to determine which protocol transitions
%%2009-02-18occurred during a trace (handled by depth first search and
%%2009-02-18backtracking), and to find values for under-constrained host fields
%%2009-02-18(handled by maintaining a set of constraints which are progressively
%%2009-02-18simplified), and a typical validation run can take several weeks. Even
%%2009-02-18so, the protocol model was extensively validated, see
%%2009-02-18Sect. \ref{sect:packet}.
%%2009-02-18
%%2009-02-18Service-level validation resembles protocol-level validation, in that
%%2009-02-18real-world implementations are used to generate traces which are then
%%2009-02-18checked against the formal specification. We do not expect traces that
%%2009-02-18fail protocol-level validation to pass service-level validation, so
%%2009-02-18for this reason we only consider traces which have already been
%%2009-02-18validated at the protocol level.
%%2009-02-18%
%%2009-02-18If a trace successfully passes protocol-level validation, it should
%%2009-02-18pass service-level validation. Failure to validate means that there is
%%2009-02-18an error in the service-level specification, or in the abstraction
%%2009-02-18function. Given that the service specification should admit all
%%2009-02-18behaviour observed at the protocol-level, these are the only
%%2009-02-18possibilities. In particular, we do not look to find ``errors in TCP''
%%2009-02-18itself, which would typically show up during protocol-level validation
%%2009-02-18(our previous work identified various anomalies that would normally be
%%2009-02-18considered bugs).
%%2009-02-18
%%2009-02-18
%%2009-02-18The service-level test oracle could be developed independently of that
%%2009-02-18at the protocol level, and service-level validation would then be a
%%2009-02-18computationally intensive task, similar to that at the protocol level.
%%2009-02-18%
%%2009-02-18The key observation is that \emph{protocol-level validation, together with
%%2009-02-18the abstraction function, can be used to significantly simplify
%%2009-02-18service-level validation}.
%%2009-02-18
%%2009-02-18The complexity of protocol-level validation is mainly due to the
%%2009-02-18depth-first search and backtracking, and the constraint handling, both
%%2009-02-18of which are necessary because real-world observed traces do not
%%2009-02-18record complete information about the state of the hosts, or the
%%2009-02-18transitions that occur. The purpose of the search and constraint
%%2009-02-18handling is to determine this missing information and so determine
%%2009-02-18which transitions occurred. In essence, the test oracle receives a
%%2009-02-18symbolic trace, with uninstantiated variables representing the unknown
%%2009-02-18information, and after possibly inserting some unobservable
%%2009-02-18transitions, produces a ground trace, valid according to the protocol
%%2009-02-18model. We rewrote our previous protocol-level oracle extensively, in
%%2009-02-18order to produce these ground traces.
%%2009-02-18
%%2009-02-18For a given trace, protocol-level validation fully determines which
%%2009-02-18transitions occurred. We map the resulting fully ground trace, using
%%2009-02-18the abstraction function, into a fully ground service-level trace.
%%2009-02-18%
%%2009-02-18It is then necessary to check validity of this trace, which requires a
%%2009-02-18service-level test oracle. Crucially the process can be a lot simpler
%%2009-02-18because each transition can be checked in isolation, rather than
%%2009-02-18resorting to depth-first search and backtracking.
%%2009-02-18%
%%2009-02-18In this way, protocol-level validation, and the abstraction function,
%%2009-02-18are used to simplify the task of service-level validation.
%%2009-02-18
%%2009-02-18%\begin{center}
%%2009-02-18%% define a table indexed by row-column coords, starting at 1,1 in top left
%%2009-02-18%\begin{psmatrix}[colsep=1mm,rowsep=1cm]
%%2009-02-18%& ground service-level trace\\
%%2009-02-18%real-world observed trace \\
%%2009-02-18%& valid ground protocol-level trace
%%2009-02-18%\end{psmatrix}
%%2009-02-18%\psset{linewidth=.1mm,nodesep=2mm}
%%2009-02-18%   %nodesep is gap between end of line and thing being connected to
%%2009-02-18%   %(the "node")
%%2009-02-18%\ncline{2,1}{1,2}
%%2009-02-18%\ncline{2,1}{3,2}
%%2009-02-18%\ncline{->}{3,2}{1,2}
%%2009-02-18%\nbput{\parbox{2cm}{abstraction function}}
%%2009-02-18%\end{center}
%%2009-02-18
%%2009-02-18Another significant difference between the two checkers is that the
%%2009-02-18service-level checker can aggressively search for instantiations of
%%2009-02-18existentially quantified variables that arise when a rule's hypothesis
%%2009-02-18has to be discharged.  At the protocol level, such variables may appear
%%2009-02-18quite unconstrained at first appearance, but then become progressively
%%2009-02-18more constrained as further steps of the trace are processed.
%%2009-02-18
%%2009-02-18For example, a simplified rule for the \texttt{socket} call might
%%2009-02-18appear as
%%2009-02-18% readers haven't seen inference rule style presentation of a rule before
%%2009-02-18\[
%%2009-02-18\infer{<[h0]> \inp{<[Lh_call (tid,socket()) ]>}
%%2009-02-18  <[h0 <| socks := socks |+ (]>\tsvar{sid}<[,fd)|>]>}{
%%2009-02-18  <[fd]>\not\in\textsf{usedfds}(<[h0]>)}
%%2009-02-18\]
%%2009-02-18stating that when a \texttt{socket} call is made, the host $h_0$'s
%%2009-02-18\texttt{socks} map is updated to associate the new socket (identified
%%2009-02-18by $\mathit{sid}$) with file-descriptor $\mathit{fd}$, subject only
%%2009-02-18to the constraint that the new descriptor not already be in use.
%%2009-02-18(This under-specification is correct on Windows; on Unices, the
%%2009-02-18file-descriptor is typically the next available natural number.)
%%2009-02-18
%%2009-02-18In the protocol-level checker, the [[fd]] variable must be left
%%2009-02-18uninstantiated until its value can be deduced from subsequent steps in
%%2009-02-18the trace.  In the service-level checker, both the initial host and the
%%2009-02-18final host are available because they are the product of the
%%2009-02-18abstraction function applied to the previously generated, and ground,
%%2009-02-18protocol trace.  In a situation such as this, the variable from
%%2009-02-18the hypothesis is present in the conclusion, and can be immediately
%%2009-02-18instantiated.
%%2009-02-18
%%2009-02-18In other rules of the service-level specification, there can be a great
%%2009-02-18many variables that occur only in the hypothesis.  These are
%%2009-02-18existentially quantified, and the checker must determine if there is
%%2009-02-18an instantiation for them that makes the hypothesis true.  The most
%%2009-02-18effective way of performing this check is to simplify, apply decision
%%2009-02-18procedures for arithmetic, and to then repeatedly case-split on
%%2009-02-18boolean variables, and the guards of \textsf{if-then-else} expressions
%%2009-02-18to search for possible instantiations.
